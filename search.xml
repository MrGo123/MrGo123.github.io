<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于UML</title>
      <link href="/2020/06/30/UML/"/>
      <url>/2020/06/30/UML/</url>
      
        <content type="html"><![CDATA[<p><strong>Unified Modeling Language (UML)</strong>又称统一建模语言或标准建模语言。</p><p>使用UML的面向对象图的方式来更明确、清晰的表达项目中的架构思想、项目结构、执行顺序等一些<strong>逻辑思维</strong>。</p><p>UML模型的三部分构成：</p><ul><li><strong>事物（Things）</strong>：UML中最基本的构成要素，是具有代表性的成分的抽象；</li><li><strong>关系（Relationships）</strong>：关系把事物联系在一起；</li><li><strong>图（Diagrams）</strong>：图是事物和关系的可视化表示。</li></ul><a id="more"></a><h3 id="UML构建模块"><a href="#UML构建模块" class="headerlink" title="UML构建模块"></a>UML构建模块</h3><h4 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h4><p>事物是是实体抽象化的最终结果，是 UML 构建块最重要的组成部分，事物的分类如下:</p><ul><li>结构事物<ul><li>类</li><li>接口</li><li>协作</li><li>用例</li><li>组件</li></ul></li><li>行为事物<ul><li>交互</li><li>状态机</li></ul></li><li>分组事物<ul><li>包</li></ul></li><li>注释事物<ul><li>注释</li></ul></li></ul><h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><p>关系是另一个最重要的构建块UML，它显示元素是如何彼此相关联，此关联描述的一个应用程序的功能，UML中定义了四种关系：</p><ul><li>依赖关系</li><li>协作</li><li>泛化</li><li>实现</li></ul><h4 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h4><p>UML 图的视觉效果是整个过程中最重要的部分。分为：</p><ol><li>类图：类图描述系统所包含的类、类的内部结构及类之间的关系；</li><li>对象图：对象图是类图的一个具体实例；</li><li>用例图：用例图从用户的角度出发描述系统的功能、需求，展示系统外部的各类角色与系统内部的各种用例之间的关系；</li><li>顺序图：顺序图表示对象之间动态合作的关系；</li><li>协作图：协作图描述对象之间的协作关系；</li><li>活动图：活动图描述系统中各种活动的执行顺序。</li><li>状态图：状态图描述一类对象的所有可能的状态以及事件发生时状态的转移条件；</li><li>部署关系图：部署关系图定义系统中软硬件的物理体系结构；</li><li>组件图：组件图描述代码部件的物理结构以及各部件之间的依赖关系；</li></ol><p>根据建模类型划分，可分为：</p><ul><li>结构建模<ul><li>类图</li><li>对象图</li><li>部署图</li><li>包图</li><li>复合结构图</li><li>组件图</li></ul></li><li>行为建模<ul><li>活动图</li><li>交互图</li><li>用例图</li></ul></li><li>架构建模<ul><li>包图</li></ul></li></ul><h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><p>类图（Class Diagram）是面向对象系统建模中最常用和最重要的图，是定义其它图的基础。</p><p>类图主要是用来显示系统中的类、接口以及它们之间的静态结构和关系的一种静态模型。</p><p>类图不仅用于可视化描述和记录系统的不同方面，也为构建可执行代码的软件应用程序。</p><p>类图描述一类的属性和操作，也对系统的约束。被广泛应用于类图的建模的面向对象的系统中，因为它们是唯一的，可以直接映射到面向对象的语言的 UML 图。</p><p>类图显示集合的类，接口，关联，协作和约束，它也被称为作为结构图。</p><p><img src="https://cdn.jsdelivr.net/gh/MrGo123/asset@master/sourceinpost/DesignPatterns/UMLClass.png" alt="UMLClass"></p><p>一个类图的综合例子</p><p><img src="https://cdn.jsdelivr.net/gh/MrGo123/asset@master/sourceinpost/DesignPatterns/classDiagrameg.png" alt="ClassDiagram"></p><p>In the example above:</p><p>We can interpret the meaning of the above class diagram by reading through the points as following.</p><ol><li>Shape is an abstract class. It is shown in Italics.</li><li>Shape is a superclass. Circle, Rectangle and Polygon are derived from Shape. In other words, a Circle is-a Shape. This is a generalization / inheritance relationship.</li><li>There is an association between DialogBox and DataController.</li><li>Shape is part-of Window. This is an aggregation relationship. Shape can exist without Window.</li><li>Point is part-of Circle. This is a composition relationship. Point cannot exist without a Circle.</li><li>Window is dependent on Event. However, Event is not dependent on Window.</li><li>The attributes of Circle are radius and center. This is an entity class.</li><li>The method names of Circle are area(), circum(), setCenter() and setRadius().</li><li>The parameter radius in Circle is an in parameter of type float.</li><li>The method area() of class Circle returns a value of type double.</li><li>The attributes and method names of Rectangle are hidden. Some other classes in the diagram also have their attributes and method names hidden.</li></ol><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://www.w3cschool.cn/uml_tutorial/" target="_blank" rel="noopener">W3CSchool——UML 教程</a></p><p><a href="https://www.visual-paradigm.com/guide/uml-unified-modeling-language/what-is-class-diagram/" target="_blank" rel="noopener">What is class diagram-visual Paradigm</a></p>]]></content>
      
      
      <categories>
          
          <category> Design Patterns </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(码)Linux C编程一站式学习</title>
      <link href="/2020/06/23/Linux%20C%E7%BC%96%E7%A8%8B%E4%B8%80%E7%AB%99%E5%BC%8F%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/06/23/Linux%20C%E7%BC%96%E7%A8%8B%E4%B8%80%E7%AB%99%E5%BC%8F%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>码一本Linux C编程的书——<a href="https://www.kancloud.cn/wizardforcel/linux-c-book/134922" target="_blank" rel="noopener">《Linux C编程一站式学习》</a>。这里提供书籍提供目录。</p><a id="more"></a><p><strong>特点</strong></p><ul><li><p>不是孤立地讲C语言，而是和编译原理、操作系统、计算机体系结构结合起来讲。或者说，本书的内容只是以C语言为载体，真正讲的是计算机的原理和程序的原理。</p></li><li><p>强调基本概念和基本原理，在编排顺序上非常重视概念之间的依赖关系，每次引入一个新的概念，只依赖于前面章节已经讲过的概念，而绝不会依赖后面章节要讲的概念。有些地方为了叙述得完整，也会引用后面要讲的内容，比如说“有关XX我们到XX章再仔细讲解”，凡是这种引用都不是必要的依赖，可以当它不存在，只管继续往下看就行了。</p></li><li><p>尽量做到每个知识点直到要用的时候才引入。过早引入一个知识点，讲完了又不用它，读者很快就会遗忘，这是不符合认知规律的。</p></li></ul><p><strong>前备要求</strong></p><ul><li><p>一本从零基础开始学习编程的书，不要求读者有任何编程经验，但读者至少需要具备以下素质：</p></li><li><p>熟悉Linux系统的基本操作。如果不具备这一点，请先参考其它教材学习Linux系统的基本操作，熟练之后再学习本书，《鸟哥的Linux私房菜》据说是Linux系统管理和应用方面比较好的一本书。但学习本书并不需要会很多系统管理技术，只要会用基本命令，会自己安装系统和软件包就足够了。</p></li><li><p>具有高中毕业的数学水平。本书会用到高中的数学知识，事实上，如果不具有高中毕业的数学水平，也不必考虑做程序员了。但并不是说只要具有高中毕业的数学水平就足够做程序员了，只能说看这本书应该没有问题，数学是程序员最重要的修养，计算机科学其实就是数学的一个分支，如果你的数学功底很差，日后还需恶补一下。</p></li><li><p>具有高中毕业的英文水平。理由同上。</p></li><li><p>对计算机的原理和本质深感兴趣，不是为就业而学习，不是为拿高薪而学习，而是真的感兴趣，想把一切来龙去脉搞得清清楚楚而学习。</p></li><li><p>勤于思考。本书尽最大努力理清概念之间的依赖关系，力求一站式学习，读者不需要为了找一个概念的定义去翻其它书，也不需要为了搞清楚一个概念在本书中前后一通乱翻，只需从前到后按顺序学习即可。但一站式学习并不等于傻瓜式学习，有些章节有一定的难度，需要积极思考才能领会。本书可以替你节省时间，但不能替你思考，不要指望像看小说一样走马观花看一遍就能学会。</p></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wsl中windows与子系统的交互</title>
      <link href="/2020/06/20/wsl%E4%B8%ADwindows%E4%B8%8E%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BA%A4%E4%BA%92/"/>
      <url>/2020/06/20/wsl%E4%B8%ADwindows%E4%B8%8E%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BA%A4%E4%BA%92/</url>
      
        <content type="html"><![CDATA[<p>当我们要在wsl下对Windows系统操作时，需要使用 <code>/mnt/……</code> 命令。为什么？？ <code>/mnt</code> 与Windows有什么关系？？</p><a id="more"></a><p>在Linux系统的文件根目录下，有名为 <code>/mnt</code> 的目录。CD2 ROM、软盘这类可移动介质的挂载点目录一般放在/ mnt 目录下, 通常有cdrom和floppy 两个子目录, 分别是光盘和软盘的挂载安装点。通过挂载光盘或软盘后, 对应进入/ mnt/ cdrom 或/ mnt/ floppy 子目录, 就可访问光盘或软盘中的内容。注意挂载点目录中不要有任何文件, 否则将无法正常挂载。————《Linux服务器的配置与管理-冯昊》</p><p>因此，Windows子系统下的Linux系统就是通过 <code>/mnt</code> 目录来连通与Windows的联系。我们可以通过 <code>/mnt</code> 访问Windows下的各个磁盘，如同在Windows下一样。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell</title>
      <link href="/2020/06/17/Shell/"/>
      <url>/2020/06/17/Shell/</url>
      
        <content type="html"><![CDATA[<p>shell简介</p><a id="more"></a><hr><h3 id="shell简介"><a href="#shell简介" class="headerlink" title="shell简介"></a>shell简介</h3><p>Shell 诞生于 Unix，是与 Unix/Linux 交互的工具。Shell虽然是Unix的第一个<strong>脚本语言</strong>，但它是相当优秀的。它结合了延展性与效率，持续保有独具的特色，并不断的被改良，使它多年来能与那些花招很多的脚本语言保持抗衡。</p><p>Shell需要依赖其他程序才能完成大部分的工作，这或许是它的缺陷，但它不容置疑的长处是：简洁的脚本语言标记方式，而且比C语言编写的程序执行更快、更有效率。</p><p>Shell 是将内核、程序和用户连接了起来的<strong>软件</strong>。</p><p>Shell 本身支持的命令并不多，但是<strong>它可以调用其他的程序，每个程序就是一个命令</strong>，这使得 Shell 命令的数量可以无限扩展，其结果就是 Shell 的功能非常强大。</p><p>shell是一种脚本语言，因此需要编译成二进制的形式才可以被计算机执行。</p><p>几种常见的Shell：sh、bash、csh、tcsh、ash。其中默认的是bash，使用 <code>echo $SHELL</code> 查看默认的shell。 <code>SHELL</code> 是 Linux 系统中的环境变量，它指明了当前使用的 Shell 程序的位置，也就是使用的哪个 Shell。</p><p>对于普通用户，Base shell 默认的提示符是美元符号$；对于超级用户（root 用户），Bash Shell 默认的提示符是井号#</p><p>echo 是一个输出命令，可以用来输出数字、变量、字符串等；</p><p>bash shell中变量都是字符串类型，使用变量在变量名前加 <code>$</code>,变量名外面的花括号<code>{ }</code>是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界</p><p>单双引号的区别：单引号’ ‘包围变量的值时，单引号里面是什么就输出什么，即使内容中有变量和命令（命令需要反引起来）也会把它们原样输出。双引号” “包围变量的值时，输出时会先解析里面的变量和命令，而不是把双引号中的变量名和命令原样输出。</p><p>使用 <code>$(变量名or内容)</code> 读取变量的值or内容。</p><p>声明<strong>只读变量</strong> <code>readonly 变量名</code>，删除变量 <code>unset 变量名</code></p><p>变量类型<br>运行shell时，会同时存在三种变量：</p><p>1) 局部变量<br>局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。<br>2) 环境变量<br>所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。<br>3) shell变量<br>shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</p><p>特殊变量列表<br>| 变量  |                                             含义                                             |<br>| :—: | :——————————————————————————————: |<br>|  $0   |                                       当前脚本的文件名                                       |<br>|  $n   | 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。 |<br>|  $#   |                                 传递给脚本或函数的参数个数。                                 |<br>|  $*   |                                 传递给脚本或函数的所有参数。                                 |<br>|  $@   |       传递给脚本或函数的所有参数。被双引号(“ “)包含时，与 $* 稍有不同，下面将会讲到。        |<br>|  $?   |              上个命令的退出状态（上一个命令执行后的返回结果），或函数的返回值。              |<br>|  $$   |                 当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。                 |</p><p>命令行参数</p><p>命令行参数<br>运行脚本时传递给脚本的参数称为命令行参数。命令行参数用 $n 表示，例如，$1 表示第一个参数，$2 表示第二个参数，依次类推。</p><p>请看下面的脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"File Name: <span class="variable">$0</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"First Parameter : <span class="variable">$1</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"First Parameter : <span class="variable">$2</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Quoted Values: <span class="variable">$@</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Quoted Values: $*"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Total Number of Parameters : <span class="variable">$#</span>"</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$./test.sh Zara Ali</span><br><span class="line">File Name : ./test.sh</span><br><span class="line">First Parameter : Zara</span><br><span class="line">Second Parameter : Ali</span><br><span class="line">Quoted Values: Zara Ali</span><br><span class="line">Quoted Values: Zara Ali</span><br><span class="line">Total Number of Parameters : 2</span><br></pre></td></tr></table></figure><p>注：$* 和 $@ 的区别</p><table><thead><tr><th align="center">转义字符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">\</td><td align="center">反斜杠</td></tr><tr><td align="center">\a</td><td align="center">警报，响铃</td></tr><tr><td align="center">\b</td><td align="center">退格（删除键）</td></tr><tr><td align="center">\f</td><td align="center">换页(FF)，将当前位置移到下页开头</td></tr><tr><td align="center">\n</td><td align="center">换行</td></tr><tr><td align="center">\r</td><td align="center">回车</td></tr><tr><td align="center">\t</td><td align="center">水平制表符（tab键）</td></tr><tr><td align="center">\v</td><td align="center">垂直制表符</td></tr></tbody></table><p>可以使用 echo 命令的 -E 选项禁止转义，默认也是不转义的；使用 -n 选项可以禁止插入换行符。</p><p><strong>命令替换</strong><br>命令替换是指Shell可以先执行命令，将输出结果暂时保存，在适当的地方输出。<br>命令替换的语法：<code>command</code></p><p>将命令执行结果保存在变量中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">DATE=`date`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Date is <span class="variable">$DATE</span>"</span></span><br><span class="line">USERS=`who | wc -l`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Logged in user are <span class="variable">$USERS</span>"</span></span><br><span class="line">UP=`date ; uptime`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Uptime is <span class="variable">$UP</span>"</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Date is Thu Jul  2 03:59:57 MST 2009</span><br><span class="line">Logged <span class="keyword">in</span> user are 1</span><br><span class="line">Uptime is Thu Jul  2 03:59:57 MST 2009</span><br><span class="line">03:59:57 up 20 days, 14:03,  1 user,  load avg: 0.13, 0.07, 0.15</span><br></pre></td></tr></table></figure><p><strong>变量替换</strong><br>变量替换可以根据变量的状态（是否为空、是否定义等）来改变它的值</p><p>可以使用的变量替换形式：<br>|      形式       |                                                                               说明                                                                                |<br>| :————-: | :—————————————————————————————————————————————————————: |<br>|     ${var}      |                                                                           变量本来的值                                                                            |<br>|  ${var:-word}   |                                              如果变量 var 为空或已被删除(unset)，那么返回 word，但不改变 var 的值。                                               |<br>|  ${var:=word}   |                                           如果变量 var 为空或已被删除(unset)，那么返回 word，并将 var 的值设置为 word。                                           |<br>| ${var:?message} | 如果变量 var 为空或已被删除(unset)，那么将消息 message 送到标准错误输出，可以用来检测变量 var 是否可以被正常赋值。若此替换出现在Shell脚本中，那么脚本将停止运行。 |<br>|  ${var:+word}   |                                                      如果变量 var 被定义，那么返回 word，但不改变 var 的值。                                                      |</p><h3 id="shell运算符"><a href="#shell运算符" class="headerlink" title="shell运算符"></a>shell运算符</h3><p>原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。</p><p>算数运算符</p><table><thead><tr><th align="center">运算符</th><th align="center">说明</th><th align="center">举例</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">加法</td><td align="center"><code>expr $a + $b</code> 结果为 30。</td></tr><tr><td align="center">-</td><td align="center">减法</td><td align="center"><code>expr $a - $b</code> 结果为 10。</td></tr><tr><td align="center">*</td><td align="center">乘法</td><td align="center"><code>expr $a \* $b</code> 结果为  200。</td></tr><tr><td align="center">/</td><td align="center">除法</td><td align="center"><code>expr $b / $a</code> 结果为 2。</td></tr><tr><td align="center">%</td><td align="center">取余</td><td align="center"><code>expr $b % $a</code> 结果为 0。</td></tr><tr><td align="center">=</td><td align="center">赋值</td><td align="center">a=$b 将把变量 b 的值赋给 a。</td></tr><tr><td align="center">==</td><td align="center">相等。用于比较两个数字，相同则返回 true。    [ $a == $b ] 返回 false。</td><td align="center"></td></tr><tr><td align="center">!=</td><td align="center">不相等。用于比较两个数字，不相同则返回 true。    [ $a != $b ] 返回 true。</td><td align="center"></td></tr></tbody></table><p>关系运算符列表</p><table><thead><tr><th align="center">运算符</th><th align="center">说明</th><th align="center">举例</th></tr></thead><tbody><tr><td align="center">-eq</td><td align="center">检测两个数是否相等，相等返回 true。</td><td align="center">[ $a -eq $b ] 返回 true。</td></tr><tr><td align="center">-ne</td><td align="center">检测两个数是否相等，不相等返回 true。</td><td align="center">[ $a -ne $b ] 返回 true。</td></tr><tr><td align="center">-gt</td><td align="center">检测左边的数是否大于右边的，如果是，则返回 true。</td><td align="center">[ $a -gt $b ] 返回 false。</td></tr><tr><td align="center">-lt</td><td align="center">检测左边的数是否小于右边的，如果是，则返回 true。</td><td align="center">[ $a -lt $b ] 返回 true。</td></tr><tr><td align="center">-ge</td><td align="center">检测左边的数是否大等于右边的，如果是，则返回 true。</td><td align="center">[ $a -ge $b ] 返回 false。</td></tr><tr><td align="center">-le</td><td align="center">检测左边的数是否小于等于右边的，如果是，则返回 true。</td><td align="center">[ $a -le $b ] 返回 true。</td></tr></tbody></table><p>布尔运算符列表</p><table><thead><tr><th align="center">运算符</th><th align="center">说明</th><th align="center">举例</th></tr></thead><tbody><tr><td align="center">!</td><td align="center">非运算，表达式为 true 则返回 false，否则返回 true。</td><td align="center">[ ! false ] 返回 true。</td></tr><tr><td align="center">-o</td><td align="center">或运算，有一个表达式为 true 则返回 true。</td><td align="center">[ $a -lt 20 -o $b -gt 100 ] 返回 true。</td></tr><tr><td align="center">-a</td><td align="center">与运算，两个表达式都为 true 才返回 true。</td><td align="center">[ $a -lt 20 -a $b -gt 100 ] 返回 false。</td></tr></tbody></table><p>字符串运算符列表</p><table><thead><tr><th align="center">运算符</th><th align="center">说明</th><th align="center">举例</th></tr></thead><tbody><tr><td align="center">=</td><td align="center">检测两个字符串是否相等，相等返回 true。</td><td align="center">[ $a = $b ] 返回 false。</td></tr><tr><td align="center">!=</td><td align="center">检测两个字符串是否相等，不相等返回 true。</td><td align="center">[ $a != $b ] 返回 true。</td></tr><tr><td align="center">-z</td><td align="center">检测字符串长度是否为0，为0返回 true。</td><td align="center">[ -z $a ] 返回 false。</td></tr><tr><td align="center">-n</td><td align="center">检测字符串长度是否为0，不为0返回 true。</td><td align="center">[ -z $a ] 返回 true。</td></tr><tr><td align="center">str</td><td align="center">检测字符串是否为空，不为空返回 true。</td><td align="center">[ $a ] 返回 true。</td></tr></tbody></table><p>文件测试运算符</p><table><thead><tr><th align="center">操作符</th><th align="center">说明</th><th align="center">举例</th></tr></thead><tbody><tr><td align="center">-b file</td><td align="center">检测文件是否是块设备文件，如果是，则返回 true。</td><td align="center">[ -b $file ] 返回 false。</td></tr><tr><td align="center">-c file</td><td align="center">检测文件是否是字符设备文件，如果是，则返回 true。</td><td align="center">[ -b $file ] 返回 false。</td></tr><tr><td align="center">-d file</td><td align="center">检测文件是否是目录，如果是，则返回 true。</td><td align="center">[ -d $file ] 返回 false。</td></tr><tr><td align="center">-f file</td><td align="center">检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td><td align="center">[ -f $file ] 返回 true。</td></tr><tr><td align="center">-g file</td><td align="center">检测文件是否设置了 SGID 位，如果是，则返回 true。</td><td align="center">[ -g $file ] 返回 false。</td></tr><tr><td align="center">-k file</td><td align="center">检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td><td align="center">[ -k $file ] 返回 false。</td></tr><tr><td align="center">-p file</td><td align="center">检测文件是否是具名管道，如果是，则返回 true。</td><td align="center">[ -p $file ] 返回 false。</td></tr><tr><td align="center">-u file</td><td align="center">检测文件是否设置了 SUID 位，如果是，则返回 true。</td><td align="center">[ -u $file ] 返回 false。</td></tr><tr><td align="center">-r file</td><td align="center">检测文件是否可读，如果是，则返回 true。</td><td align="center">[ -r $file ] 返回 true。</td></tr><tr><td align="center">-w file</td><td align="center">检测文件是否可写，如果是，则返回 true。</td><td align="center">[ -w $file ] 返回 true。</td></tr><tr><td align="center">-x file</td><td align="center">检测文件是否可执行，如果是，则返回 true。</td><td align="center">[ -x $file ] 返回 true。</td></tr><tr><td align="center">-s file</td><td align="center">检测文件是否为空（文件大小是否大于0），不为空返回 true。</td><td align="center">[ -s $file ] 返回 true。</td></tr><tr><td align="center">-e file</td><td align="center">检测文件（包括目录）是否存在，如果是，则返回 true。</td><td align="center">[ -e $file ] 返回 true。</td></tr></tbody></table><p>字符串</p><p>除了单双引号的区别外，还有：<br>拼接字符串</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">your_name=<span class="string">"qinjx"</span></span><br><span class="line">greeting=<span class="string">"hello, "</span><span class="variable">$your_name</span><span class="string">" !"</span></span><br><span class="line">greeting_1=<span class="string">"hello, <span class="variable">$&#123;your_name&#125;</span> !"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$greeting</span> <span class="variable">$greeting_1</span></span><br></pre></td></tr></table></figure><p>获取字符串长度</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string=<span class="string">"abcd"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#string&#125;</span> <span class="comment">#输出 4</span></span><br></pre></td></tr></table></figure><p>提取子字符串</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string=<span class="string">"alibaba is a great company"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;string:1:4&#125;</span> <span class="comment">#输出liba</span></span><br></pre></td></tr></table></figure><p>查找子字符串</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string=<span class="string">"alibaba is a great company"</span></span><br><span class="line"><span class="built_in">echo</span> `expr index <span class="string">"<span class="variable">$string</span>"</span> is`</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>bash支持一维数组（不支持多维数组），并且没有限定数组的大小。</p><h4 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">array_name=(value0 value1 value2 value3)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">array_name=(</span><br><span class="line">value0</span><br><span class="line">value1</span><br><span class="line">value2</span><br><span class="line">value3</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 单独定义</span></span><br><span class="line">array_name[0]=value0</span><br><span class="line">array_name[1]=value1</span><br><span class="line">array_name[2]=value2</span><br></pre></td></tr></table></figure><h4 id="使用数组"><a href="#使用数组" class="headerlink" title="使用数组"></a>使用数组</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">valuen=<span class="variable">$&#123;array_name[2]&#125;</span></span><br><span class="line"><span class="comment"># 使用@ 或 * 可以获取数组中的所有元素，例如：</span></span><br><span class="line"><span class="variable">$&#123;array_name[*]&#125;</span></span><br><span class="line"><span class="variable">$&#123;array_name[@]&#125;</span></span><br></pre></td></tr></table></figure><h4 id="获取数组长度"><a href="#获取数组长度" class="headerlink" title="获取数组长度"></a>获取数组长度</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取得数组元素的个数</span></span><br><span class="line">length=<span class="variable">$&#123;#array_name[@]&#125;</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">length=<span class="variable">$&#123;#array_name[*]&#125;</span></span><br><span class="line"><span class="comment"># 取得数组单个元素的长度</span></span><br><span class="line">lengthn=<span class="variable">$&#123;#array_name[n]&#125;</span></span><br></pre></td></tr></table></figure><h3 id="输出语句"><a href="#输出语句" class="headerlink" title="输出语句"></a>输出语句</h3><p>echo和printf(C语言中的printf，只是没有括号，其他不变)，printf是echo的升级版。</p><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> == <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"a is equal to b"</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$a</span> -gt <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"a is greater than b"</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$a</span> -lt <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"a is less than b"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"None of the condition met"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="test命令"><a href="#test命令" class="headerlink" title="test命令"></a>test命令</h3><p>shell中的 test 命令用于检查某个条件是否成立，它可以进行<a href="#shell运算符">数值、字符和文件</a>三个方面的测试。</p><p><strong>数值测试</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">num1=100</span><br><span class="line">num2=100</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> $[num1] -eq $[num2]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'The two numbers are equal!'</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'The two numbers are not equal!'</span> <span class="comment"># 输出结果</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p><del>比较运算符它不香吗？？</del></p><p><strong>字符串测试</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">num1=100</span><br><span class="line">num2=100</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> num1=num2</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'The two strings are equal!'</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'The two strings are not equal!'</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p><strong>文件测试</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /bin</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> -e ./bash</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'The file already exists!'</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'The file does not exists!'</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="case命令"><a href="#case命令" class="headerlink" title="case命令"></a>case命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'Input a number between 1 to 4'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'Your number is:\c'</span></span><br><span class="line"><span class="built_in">read</span> aNum</span><br><span class="line"><span class="keyword">case</span> <span class="variable">$aNum</span> <span class="keyword">in</span></span><br><span class="line">    1)  <span class="built_in">echo</span> <span class="string">'You select 1'</span></span><br><span class="line">    ;;</span><br><span class="line">    2)  <span class="built_in">echo</span> <span class="string">'You select 2'</span></span><br><span class="line">    ;;</span><br><span class="line">    3)  <span class="built_in">echo</span> <span class="string">'You select 3'</span></span><br><span class="line">    ;;</span><br><span class="line">    4)  <span class="built_in">echo</span> <span class="string">'You select 4'</span></span><br><span class="line">    ;;</span><br><span class="line">    *)  <span class="built_in">echo</span> <span class="string">'You do not select a number between 1 to 4'</span></span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p>取值后面必须为关键字 in，每一模式必须以右括号结束。取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。;; 与其他语言中的 break 类似，意思是跳到整个 case 语句的最后。</p><p>取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。</p><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> 列表</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>列表是一组值（数字、字符串等）组成的序列，每个值通过空格分隔。每循环一次，就将列表中的下一个值赋给变量。</p><p>in 列表是可选的，如果不用它，for 循环使用命令行的位置参数。</p><p>显示主目录下以 .bash 开头的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">for</span> FILE <span class="keyword">in</span> <span class="variable">$HOME</span>/.bash*</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="variable">$FILE</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/root/.bash_history</span><br><span class="line">/root/.bash_logout</span><br><span class="line">/root/.bash_profile</span><br><span class="line">/root/.bashrc</span><br></pre></td></tr></table></figure><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaSE-注解</title>
      <link href="/2020/06/13/javaSE-%E6%B3%A8%E8%A7%A3/"/>
      <url>/2020/06/13/javaSE-%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>简单记录注解</p><a id="more"></a><hr><h3 id="认识注解"><a href="#认识注解" class="headerlink" title="认识注解"></a>认识注解</h3><p>注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”。</p><p>注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。</p><p>注解的三个分类：</p><ol><li>第一类——编译器使用的注解，例如</li></ol><p><code>@Override</code>：让编译器检查该方法是否正确地实现了覆写；</p><p><code>@SuppressWarnings</code>：告诉编译器忽略此处代码产生的警告。</p><p>这类注解不会被编译进入.class文件，它们在编译后就被编译器扔掉了。</p><ol start="2"><li>第二类——由工具处理.class文件使用的注解.</li><li>第三类——在程序运行期能够读取的注解。在加载后一直存在于JVM中，是最常用的注解。</li></ol><p>定义一个注解时，可以定义配置参数。如果参数名称是value，且只有一个参数，那么可以省略参数名称。</p><h3 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h3><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1265102803921888" target="_blank" rel="noopener">廖雪峰——Java教程</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> javaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaSE-反射</title>
      <link href="/2020/06/12/javaSE-%E5%8F%8D%E5%B0%84/"/>
      <url>/2020/06/12/javaSE-%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<p>认识反射和Class类 + 访问对象的字段 + 调用对象的方法 + 调用构造函数 + 获取继承关系 + 动态代理</p><a id="more"></a><h3 id="认识反射和Class类"><a href="#认识反射和Class类" class="headerlink" title="认识反射和Class类"></a>认识反射和Class类</h3><p>反射（Reflection），Java的反射是指程序在运行期可以拿到一个对象的所有信息。</p><p>JVM为每个加载的 <code>class</code>及 <code>interface</code>创建了对应的 <code>Class</code>实例来保存 <code>class</code>及 <code>interface</code>的所有信息；这里的 <code>Class</code>类型是一个名叫 <code>Class</code>的 <code>class</code>。</p><p>获取一个 <code>class</code>对应的 <code>Class</code>实例后，就可以获取该 <code>class</code>的所有信息；</p><p>通过 <code>Class</code> 实例获取 <code>class</code> 信息的方法称为<strong>反射</strong>（Reflection）；</p><p>JVM总是动态加载class，可以在运行期根据条件来控制加载class。</p><h3 id="访问对象的字段"><a href="#访问对象的字段" class="headerlink" title="访问对象的字段"></a>访问对象的字段</h3><p>Java的反射API提供的Field类封装了字段的所有信息：</p><p>通过Class实例的方法可以获取Field实例：</p><ul><li>Field getField(name)：根据字段名获取某个public的field（包括父类）</li><li>Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）</li><li>Field[] getFields()：获取所有public的field（包括父类）</li><li>Field[] getDeclaredFields()：获取当前类的所有field（不包括父类）</li></ul><p>通过Field实例可以获取字段信息：</p><ul><li>getName()：返回字段名称，例如，”name”；</li><li>getType()：返回字段类型，也是一个Class实例，例如，String.class；</li><li>getModifiers()：返回字段的修饰符，它是一个int，不同的bit表示不同的含义。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="comment">//       拿到实例的字段</span></span><br><span class="line">        Class std= Student<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        System.out.println(std.getField(<span class="string">"score"</span>));</span><br><span class="line">        System.out.println(std.getField(<span class="string">"name"</span>));</span><br><span class="line">        System.out.println(std.getDeclaredField(<span class="string">"grade"</span>));</span><br><span class="line"><span class="comment">//      拿到实例字段对应的值。</span></span><br><span class="line">        Object p= <span class="keyword">new</span> Student(<span class="number">45</span>);</span><br><span class="line">        Class c=p.getClass();</span><br><span class="line">        Field f=c.getDeclaredField(<span class="string">"score"</span>);</span><br><span class="line">        Object value =f.get(p);</span><br><span class="line">        System.out.println(value);</span><br><span class="line"><span class="comment">//        修改字段值</span></span><br><span class="line">        f.set(p, <span class="number">50</span>);</span><br><span class="line">        Student q=(Student)p;<span class="comment">//p为Object型，强制转为Student型。</span></span><br><span class="line">        System.out.println(q.getScore()); <span class="comment">// "Xiao Hong"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> grade;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> score)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score=score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> Student.score</span><br><span class="line"><span class="keyword">public</span> java.lang.String Person.name</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> Student.grade</span><br><span class="line"><span class="number">45</span></span><br><span class="line"><span class="number">50</span></span><br></pre></td></tr></table></figure><p>通过Field实例可以读取或设置某个对象的字段，如果存在访问限制，要首先调用setAccessible(true)来访问非public字段。</p><p>通过反射读写字段是一种非常规方法，它会破坏对象的封装。因此多用于底层设计。</p><h3 id="调用对象的方法"><a href="#调用对象的方法" class="headerlink" title="调用对象的方法"></a>调用对象的方法</h3><p>java的反射API提供的 <code>Method</code>对象封装了方法的所有信息：</p><p>通过 <code>Class</code>实例的方法可以获取 <code>Method</code>实例：</p><ul><li>Method getMethod(name, Class…)：获取某个public的Method（包括父类）</li><li>Method getDeclaredMethod(name, Class…)：获取当前类的某个Method（不包括父类）</li><li>Method[] getMethods()：获取所有public的Method（包括父类）</li><li>Method[] getDeclaredMethods()：获取当前类的所有Method（不包括父类）</li></ul><p>通过 <code>Method</code> 实例可以获取方法信息：</p><ul><li>getName()：返回方法名称，例如：”getScore”；</li><li>getReturnType()：返回方法返回值类型，也是一个Class实例，例如：String.class；</li><li>getParameterTypes()：返回方法的参数类型，是一个Class数组，例如：{String.class, int.class}；</li><li>getModifiers()：返回方法的修饰符，它是一个int，不同的bit表示不同的含义。</li></ul><p>通过 <code>Method</code> 实例可以调用某个对象的方法：<code>Object invoke(Object instance, Object... parameters);</code></p><p>通过设置 <code>setAccessible(true)</code>来访问非public方法；</p><p>通过反射调用方法时，仍然遵循多态原则。</p><h3 id="调用构造函数"><a href="#调用构造函数" class="headerlink" title="调用构造函数"></a>调用构造函数</h3><p>通过Class实例获取Constructor的方法如下：</p><ul><li>getConstructor(Class…)：获取某个public的Constructor；</li><li>getDeclaredConstructor(Class…)：获取某个Constructor；</li><li>getConstructors()：获取所有public的Constructor；</li><li>getDeclaredConstructors()：获取所有Constructor。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取构造方法Integer(int):</span></span><br><span class="line">        Constructor cons1 = Integer.class.getConstructor(<span class="keyword">int</span>.class);</span><br><span class="line">        <span class="comment">// 调用构造方法:</span></span><br><span class="line">        Integer n1 = (Integer) cons1.newInstance(<span class="number">123</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(n1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取构造方法Integer(String)</span></span><br><span class="line">        Constructor cons2 = Integer.class.getConstructor(<span class="keyword">String</span>.class);</span><br><span class="line">        Integer n2 = (Integer) cons2.newInstance(<span class="string">"456"</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(n2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取继承关系"><a href="#获取继承关系" class="headerlink" title="获取继承关系"></a>获取继承关系</h3><p>通过Class对象可以获取继承关系：</p><ul><li>Class getSuperclass()：获取父类类型；</li><li>Class[] getInterfaces()：获取当前类实现的所有接口。</li></ul><p>通过Class对象的isAssignableFrom()方法可以判断一个向上转型是否可以实现。</p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>Java标准库提供了动态代理功能，允许在运行期动态创建一个接口的实例；</p><p>动态代理是通过Proxy创建代理对象，然后将接口方法“代理”给InvocationHandler完成的。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255945147512512" target="_blank" rel="noopener">廖雪峰的Java教程——反射</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> javaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gcc编译和Gdb调试</title>
      <link href="/2020/06/10/Gcc%E7%BC%96%E8%AF%91C%E8%AF%AD%E8%A8%80/"/>
      <url>/2020/06/10/Gcc%E7%BC%96%E8%AF%91C%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<p>Gcc简介+Gcc编译流程及主要相关命令。</p><a id="more"></a><h2 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h2><h3 id="gcc简介"><a href="#gcc简介" class="headerlink" title="gcc简介"></a>gcc简介</h3><p>GNU编译器套装（英语：GNU Compiler Collection，缩写为GCC），指一套编程语言编译器，以GPL及LGPL许可证所发行的自由软件，也是GNU计划的关键部分，也是GNU工具链的主要组成部分之一。GCC（特别是其中的C语言编译器）也常被认为是跨平台编译器的事实标准。可处理C、C++、Fortran、Pascal、Objective-C、Java、Ada，Go等其他语言。——Wiki</p><h3 id="gcc编译流程"><a href="#gcc编译流程" class="headerlink" title="gcc编译流程"></a>gcc编译流程</h3><p>GCC 编译器在编译一个C语言程序时需要经过以下 4 步：</p><ol><li>(-E)将C语言源程序预处理，生成.i文件。</li><li>(-S)预处理后的.i文件编译成为汇编语言，生成.s文件。</li><li>(-c)将汇编语言文件经过汇编，生成目标文件.o文件。</li><li>将各个模块的.o文件链接起来生成一个可执行程序文件。</li></ol><p>注：</p><ol><li><code>.i</code>文件、<code>.s</code>文件、<code>.o</code>文件可以认为是中间文件或临时文件，如果使用 GCC 一次性完成C语言程序的编译，那么只能看到最终的可执行文件。中间文件被删除。</li><li>每一个步骤生产的文件都可以直接从.c 文件执行对应得命令后直接生成，不必按顺序。（到底还是按顺序，只是系统把它们删了）</li></ol><table><thead><tr><th align="center">gcc编译选项</th><th align="left">选项的意义</th></tr></thead><tbody><tr><td align="center">-c</td><td align="left">编译、汇编指定的源文件，但是不进行链接</td></tr><tr><td align="center">-S</td><td align="left">编译指定的源文件，但是不进行汇编</td></tr><tr><td align="center">-E</td><td align="left">预处理指定的源文件，不进行编译</td></tr><tr><td align="center">-o [file1] [file2]</td><td align="left">将文件 file2 编译成可执行文件 file1</td></tr><tr><td align="center">-I directory</td><td align="left">指定 include 包含文件的搜索目录</td></tr><tr><td align="center">-g</td><td align="left">生成调试信息，该程序可以被调试器调试</td></tr></tbody></table><p>直接编译：<code>gcc hello.c -o hello</code>，生成hello可执行文件可直接运行。</p><h2 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h2><h3 id="gdb简介"><a href="#gdb简介" class="headerlink" title="gdb简介"></a>gdb简介</h3><p>GNU调试器（英语：GNU Debugger，缩写：GDB），是GNU软件系统中的标准调试器，此外GDB也是个具有移携性的调试器，经过移携需求的调修与重新编译，如今许多的类UNIX操作系统上都可以使用GDB，而现有GDB所能支持调试的编程语言有C、C++、Pascal以及FORTRAN。——Wiki</p><p>在用gcc编译时要加上-g选项，生成的可执行文件才能用gdb进行源码级调试</p><h3 id="单步执行和跟踪"><a href="#单步执行和跟踪" class="headerlink" title="单步执行和跟踪"></a>单步执行和跟踪</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -g main.c -o main</span><br><span class="line">$ gdb main  </span><br><span class="line"><span class="comment"># 进入gdb调试</span></span><br><span class="line">$ (gdb) list 1 <span class="comment"># list命令从第一行开始列出源代码，单纯list或l列出10行</span></span><br><span class="line">$ (gdb) next   <span class="comment"># next或n——单条执行指令。next 3 运行到当前位置的后三行</span></span><br><span class="line">$ (gdb) start <span class="comment">#程序再次启动调试</span></span><br><span class="line">$ (gdb) step <span class="comment">#step或s——进入函数内部跟踪执行</span></span><br><span class="line"></span><br><span class="line">$ (gdb) backtrace <span class="comment">#backtrace或bt查看函数调用的栈帧</span></span><br><span class="line">$ (gdb) frame 1 <span class="comment"># 选择1号栈帧</span></span><br><span class="line">$ (gdb) info locals <span class="comment"># info或i查看当前栈帧中变量的值</span></span><br><span class="line"></span><br><span class="line">$ (gdb) <span class="built_in">print</span> value <span class="comment"># print或p——打印变量value的值，变量也可以是表达式</span></span><br><span class="line">$ (gdb) finish <span class="comment"># 让当前程序一直运行到当前函数返回为止</span></span><br><span class="line">$ (gdb) <span class="built_in">set</span> var sum=0 <span class="comment"># 在gdb中给变量sum设值</span></span><br><span class="line">$ (gdb) run <span class="comment"># run或r——直接运行程序</span></span><br><span class="line">$ (gdb) quit <span class="comment"># quit或q退出gdb</span></span><br></pre></td></tr></table></figure><p>-g选项的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，所以在调试时必须保证gdb能找到源文件。</p><p>gdb提供了一个很方便的功能，在提示符下直接敲回车表示重复上一条命令。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="http://c.biancheng.net/view/2382.html" target="_blank" rel="noopener">C语言中文网-GCC</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux进程前后台切换</title>
      <link href="/2020/06/10/Linux%E5%89%8D%E5%90%8E%E5%8F%B0%E5%88%87%E6%8D%A2/"/>
      <url>/2020/06/10/Linux%E5%89%8D%E5%90%8E%E5%8F%B0%E5%88%87%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>切换前后台 + 进程管理</p><a id="more"></a><p>Background：在wsl上正常的下载着gdb调试器，一不小心，ctrl+z。？？？(⊙ˍ⊙)？怎么不下了？？原来是被扔到了后台，并且暂停了。这不是给我机会学（hua）习（shui）嘛？？💪💪</p><p>在基础篇 <a href="Linux.md">Linux</a>中有说到进程的一点命令：ps、top、kill等，但是跟这次的前后台有点不一样，可以操作学习一下。</p><h3 id="认识Linux前后台进程"><a href="#认识Linux前后台进程" class="headerlink" title="认识Linux前后台进程"></a>认识Linux前后台进程</h3><p>前后台，顾名思义。<br>前台进程：运行在终端（跑在脸上）的，可以直接操控，终端关闭，进程也停止。<br>后台进程：也叫守护进程（Daemon），是运行在后台的一种特殊进程，不受终端控制，它不需要终端的交互。进程的主要战场。</p><h3 id="场景实战"><a href="#场景实战" class="headerlink" title="场景实战"></a>场景实战</h3><ol><li>下载东西，执行命令后那进度条在脸上哗哗的过，但是还要用终端啊。那咋办？</li></ol><p>答：在敲下载命令后，在尾部加 <code>&amp;</code> 符号，eg：<code>sudo apt install gdb &amp;</code>，这一下载进程就会切换到后台进程下载。</p><ol start="2"><li>如果执行了呢？</li></ol><p>答： 使用 <code>jobs</code> 查看后台有哪些进程以及它的<code>jobsnum</code>，如下一个停止了的进程，[1]的1就是jobsnum，使用 <code>fg 1</code>将其调到前台。若只有一个进程，直接fg即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jobs</span><br><span class="line">      [1]+  Stopped                 sudo apt install gdb</span><br></pre></td></tr></table></figure><ol start="3"><li>如果想结束进程呢？</li></ol><p>答：<code>jobs -l</code> 查看进程pid，得到pid编号，然后 <code>kill 编号</code>，done。</p><ol start="4"><li>其他</li></ol><p>ctrl+z：把在前台的进程放到后台并暂停。<br>bg+jobsnum：启动jobsnum进程。<br>ctrl+c：在前台使用此命令，取消掉当前进程。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://blog.csdn.net/QQ1910084514/article/details/80390671" target="_blank" rel="noopener">LINUX 杀死、暂停、继续、后台运行进程</a></li><li><a href="https://blog.csdn.net/qq_36237569/article/details/82760808" target="_blank" rel="noopener">Linux进程前后台切换</a></li><li><a href="https://www.cnblogs.com/diantong/p/10395312.html" target="_blank" rel="noopener">Linux前后台进程切换</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux更换下载源镜像</title>
      <link href="/2020/06/09/Linux%E6%9B%B4%E6%8D%A2%E4%B8%8B%E8%BD%BD%E6%BA%90%E9%95%9C%E5%83%8F/"/>
      <url>/2020/06/09/Linux%E6%9B%B4%E6%8D%A2%E4%B8%8B%E8%BD%BD%E6%BA%90%E9%95%9C%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<p>更换Ubuntu的下载源镜像，回归正常速度！！</p><a id="more"></a><p>这里推<a href="https://developer.aliyun.com/mirror/" target="_blank" rel="noopener">阿里云的镜像</a></p><ol><li>用<code>lsb_release -a</code> 查看自己的Linux版本信息。</li><li>用<code>cp /etc/apt/sources.list /etc/apt/sources.list.back</code> 备份 sources.list 文件。<del>要是不保存也行</del></li><li>到镜像网里找到自己对应的Linux系统和版本。<del>那里有教</del>，复制对应的配置信息。</li><li>sudo权限编辑上述的文件——sources.list，把里面的内容全替换为复制下来的信息。</li><li>更新原有配置：<code>sudo apt-get update</code>，sudo依旧。</li><li>搞定。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重装系统+环境恢复简记</title>
      <link href="/2020/06/03/A-Rebuild-Record/"/>
      <url>/2020/06/03/A-Rebuild-Record/</url>
      
        <content type="html"><![CDATA[<p>重装Windows + 重装后系统环境的恢复（including office、Hexo and so on）</p><a id="more"></a><blockquote><p>重装windows系统的原因：版本太低、不支持新的terminal、office散架、……<br>全程有 <a href="https://shansan.top/" target="_blank" rel="noopener">ShanSan</a> 指导，丝毫不慌。just do it！！！😄😄😄</p></blockquote><h3 id="一、重装Windows系统"><a href="#一、重装Windows系统" class="headerlink" title="一、重装Windows系统"></a>一、重装Windows系统</h3><p>此次重装系统使用的是U盘PE辅助重装。</p><p>大概步骤</p><ol><li><strong>制作启动盘</strong>：<a href="http://www.wepe.com.cn/" target="_blank" rel="noopener">微PE工具箱</a>——取一个内存大于8G的U盘用来制作工具盘，下载在本地后启动安装至U盘。</li><li><strong>下载镜像</strong>：镜像——这里随便！推荐良心的<a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener">【MSDN】</a>。用复制链接可以用迅雷下。–慢就开会员咯–<br>注：1.镜像可以下至上述制作好的微PE启动盘中；2.也可存至另外一个U盘中。</li><li>选择<strong>进入刷机系统</strong> or <strong>BIOS</strong>：摁下开机键后狂戳某个键，华硕是 esc进入刷机系统，F2进入BIOS，刷机系统下选择UEFI（选择显示与U盘信息相关的选项）；如果是BIOS要修改优先启动选项（boot）。</li><li><strong>进入PE系统</strong>：使用分盘工具分盘（也可安装系统时再分），找到Windows镜像（若是另外一个U盘则插入到USB接口中），镜像装载。进入Windows安装流程。</li><li>这里省略……</li><li>finish</li><li><strong>Windows激活</strong>：支持正版。</li><li>enjoy yourself！！！</li></ol><p>详情参考：</p><ul><li>Docs——<a href="https://upsilverfox.github.io/2019/09/18/%E5%88%B7%E6%9C%BA%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">刷机教程</a></li><li>B站video——<a href="https://www.bilibili.com/video/BV1DJ411D79y" target="_blank" rel="noopener">官方ISO直装与PE两种方法教程</a></li><li>ShanSan——<a href="https://shansan.top/Collect/" target="_blank" rel="noopener">collection</a></li></ul><h3 id="二、office安装"><a href="#二、office安装" class="headerlink" title="二、office安装"></a>二、office安装</h3><p>windows自带的office Microsoft不给镜像，要到官网登录-绑卡-支付……，具体我也不知道，给钱才能装，支持正版ヾ(￣▽￣)Bye<del>Bye</del></p><p>正篇<del>~</del></p><p>依旧是上述MSDN下载office镜像（依旧有镜像流出），解压安装一套走，KMS激活使用（支持正版），enjoy yourself~~。</p><h3 id="hexo博客恢复"><a href="#hexo博客恢复" class="headerlink" title="hexo博客恢复"></a>hexo博客恢复</h3><p><strong>前备</strong></p><p>首先环境依旧：Git、Node.js、hexo<br>保存的时候，保存一部分文件：_config.yml、package.json、source、scaffold、themes。够了，其他的说拜拜。</p><p><strong>关键</strong></p><p>hexo搬迁：直接在Hexo目录下Bash，然后npm install（npm 根据hexo下保留有的package.json安装所需的包），然后npx hexo g，再然后npx hexo s，即可。</p><h3 id="三、vscode漏装补全"><a href="#三、vscode漏装补全" class="headerlink" title="三、vscode漏装补全"></a>三、vscode漏装补全</h3><p>安装vscode时，有些功能如果没勾到，可以直接运行原安装包，再次安装，勾上自己想装的部分功能即可。</p><h3 id="四、wsl2安装"><a href="#四、wsl2安装" class="headerlink" title="四、wsl2安装"></a>四、wsl2安装</h3><p>没太多要说的，看官网 <a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-win10" target="_blank" rel="noopener">适用于 Linux 的 Windows 子系统安装指南 (Windows 10)</a>，真香啊<del>~</del></p><h3 id="五、壁纸推荐"><a href="#五、壁纸推荐" class="headerlink" title="五、壁纸推荐"></a>五、壁纸推荐</h3><p>如果您喜欢动态壁纸的话，steam那个啥……wall来着，不记得。<br>静态壁纸——<a href="http://pic.netbian.com/" target="_blank" rel="noopener">彼岸图网</a>可以免费获取4K的壁纸，登录即可，每天可以免费获取一张，还不够嘛？不够再多几个账号注册？？什么？还不够？每天领double壁纸。</p><h3 id="六、说在最后"><a href="#六、说在最后" class="headerlink" title="六、说在最后"></a>六、说在最后</h3><p>ShanSan🐂🍺</p><p>如果有时间，那就多动手折腾吧。别怂，大不了…………<del>重装</del>。📴📴<a href="https://shansan.top/" target="_blank" rel="noopener">@ShanSan</a></p>]]></content>
      
      
      <categories>
          
          <category> ComputerBasic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rebuild </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Computer English</title>
      <link href="/2020/06/03/Computer-English/"/>
      <url>/2020/06/03/Computer-English/</url>
      
        <content type="html"><![CDATA[<p>Some computer term in English and its paraphrase.</p><p><strong>English makes you go further.</strong></p><a id="more"></a><blockquote><p>computer culture is extensive and profound, there is no gap at different aspect.Just mark down.📕📕。</p></blockquote><h2 id="C-C-——The-C-C-Programming"><a href="#C-C-——The-C-C-Programming" class="headerlink" title="C/C++——The C/C++ Programming"></a>C/C++——The C/C++ Programming</h2><table><thead><tr><th align="center">word</th><th align="center">编程用义</th><th align="center">有道释义</th></tr></thead><tbody><tr><td align="center">constant</td><td align="center">常量</td><td align="center">adj. 不变的；恒定的；经常的。n. [数] 常数；恒量</td></tr><tr><td align="center">variable</td><td align="center">变量</td><td align="center">adj. 变量的；可变的；易变的，多变的；变异的，[生物] 畸变的。n. [数] 变量；可变物，可变因素</td></tr><tr><td align="center">value</td><td align="center">值</td><td align="center">n. 值；价值；价格；重要性；确切涵义。vt. 评价；重视；估价</td></tr><tr><td align="center">Procedure-Based Programming</td><td align="center">基于过程的程序设计</td><td align="center">procedure——n. 程序，手续；步骤</td></tr><tr><td align="center">data structure</td><td align="center">数据结构</td><td align="center"></td></tr><tr><td align="center">pseudo code</td><td align="center">伪代码</td><td align="center">pseudo——n. 伪君子；假冒的人。adj. 冒充的，假的</td></tr><tr><td align="center">constructor</td><td align="center">构造函数</td><td align="center">n. 构造函数；构造器；建造者。复数constructors</td></tr></tbody></table><h2 id="数据库——DataBase"><a href="#数据库——DataBase" class="headerlink" title="数据库——DataBase"></a>数据库——DataBase</h2><table><thead><tr><th align="center">word</th><th align="center">编程用义</th><th align="center">有道释义</th></tr></thead><tbody><tr><td align="center">wildcard</td><td align="center">通配符</td><td align="center"></td></tr><tr><td align="center">search pattern</td><td align="center">搜索模式</td><td align="center"></td></tr></tbody></table><h2 id="计组——Principles-of-Computer-Organization"><a href="#计组——Principles-of-Computer-Organization" class="headerlink" title="计组——Principles of Computer Organization"></a>计组——Principles of Computer Organization</h2><table><thead><tr><th align="center">word (,acronym  )</th><th align="center">编程用义</th><th align="center">有道释义</th></tr></thead><tbody><tr><td align="center">Complex Instruction Set Computer,<strong>CISC</strong></td><td align="center">复杂指令系统计算机</td><td align="center"></td></tr><tr><td align="center">Reduced Instruction Set Computer,<strong>RISC</strong></td><td align="center">精简指令系统计算机</td><td align="center"></td></tr></tbody></table><h2 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h2><p>看一本Computer English书籍。了解一哈。</p><p><del>听老师说有这门课，但是我得培养方案没有。问题不大</del></p>]]></content>
      
      
      <categories>
          
          <category> ComputerBasic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL——Practice</title>
      <link href="/2020/05/30/SQL_Practice/"/>
      <url>/2020/05/30/SQL_Practice/</url>
      
        <content type="html"><![CDATA[<p>SQL</p><a id="more"></a><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><blockquote><p>基于《SQL必知必会》、《数据库原理》、《MySQL必知必会》等</p></blockquote><hr><h3 id="SQL-1"><a href="#SQL-1" class="headerlink" title="SQL"></a>SQL</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><strong>SQL</strong>（Structured Query Language，SQL） 结构化英语查询语言，非过程性语言。集数据定义语言（DDL）、数据操作语言（DML）、数据控制语言（DCL）三大功能于一体。</p><p>SQL的几个动词</p><table><thead><tr><th align="center">SQL 功能</th><th align="center">动词</th></tr></thead><tbody><tr><td align="center">数 据 查 询</td><td align="center">SELECT</td></tr><tr><td align="center">数 据 定 义</td><td align="center">CREATE，DROP，ALTER</td></tr><tr><td align="center">数 据 操 纵</td><td align="center">INSERT，UPDATE，DELETE</td></tr><tr><td align="center">数 据 控 制</td><td align="center">GRANT，REVOKE</td></tr></tbody></table><h4 id="检索-select"><a href="#检索-select" class="headerlink" title="检索 select"></a>检索 select</h4><blockquote><ol><li>如非必须，少用通配符 *，影响性能。</li><li>输出中行的值重复了：使用 <strong>DISTINCT</strong> 关键字，必须放在”列“前，且不对部分使用，是对全体列使用。</li><li>返回部分行：不同的DBMS语句不同。SQL Server eg：<br><code>select top 5 score from Course;</code></li></ol></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-- MySQL输出前几行，limit输出不超过指定行数。</span><br><span class="line">select prod_name</span><br><span class="line">from Products</span><br><span class="line">limit 3;</span><br><span class="line"></span><br><span class="line">-- 返回从第几行起的多少行数据</span><br><span class="line">-- limit指定返回的行数，offset指定从哪一行开始。第一行从0开始，即第0行。</span><br><span class="line">select prod_name</span><br><span class="line">from products</span><br><span class="line">limit 5 offset 0;</span><br><span class="line">-- 上述也可简写为：</span><br><span class="line">select prod_name</span><br><span class="line">from products</span><br><span class="line">limit 0,5;</span><br></pre></td></tr></table></figure><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>SQL三种注释</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 单行注释</span></span><br><span class="line"><span class="comment"># 单行注释</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><p>函数</p><ol><li>left(属性名,数字x) 表示取属性值的最左边x个字符</li><li>right(属性名,数字x) 表示取属性值的最右边边x个字符</li><li>lower(属性名) 表示将属性值的字母都变成小写</li><li>upper（属性名）表示将属性值的字母都变成大写</li><li>substring(属性名，起始位置L，长度x)取属性值起始位置L开始，长度为x的子串</li><li>ltrim(属性名)去除属性值最左边的空格</li><li>rtrim(属性名)去除属性值最右边的空格</li><li>trim(属性名)去除属性值首尾空格</li><li>replace(属性名,’目标’,’替代品’)将属性中的目标替换为替代品</li><li>len(属性名)取属性值的字符串长度</li></ol><hr><p>order by </p><ol><li>要使用在句末，否则报错；</li><li>多行排序时，要求按多个属性排序，则先按第一个属性排序，再在此基础上按第二个属性，以此类推。eg: <code>order by pro_price,pro_name</code> 先按商品价格排序，价格相同则按商品名称排序。</li><li>升降序：<code>DESC</code>(descending)降序、<code>ASC</code>(ascending)升序。默认升序。</li></ol><p>where</p><p>where子句操作符</p><table><thead><tr><th align="center">操作符说</th><th align="center">明</th></tr></thead><tbody><tr><td align="center">=</td><td align="center">等于</td></tr><tr><td align="center">!= 或 &lt; &gt;</td><td align="center">不等于</td></tr><tr><td align="center">&lt;</td><td align="center">小于</td></tr><tr><td align="center">&lt;= 或   !&gt;</td><td align="center">小于等于</td></tr><tr><td align="center">&gt;</td><td align="center">大于</td></tr><tr><td align="center">&gt;=  或 !&lt;</td><td align="center">大于等于</td></tr><tr><td align="center">BETWEEN</td><td align="center">在指定的两个值之间</td></tr><tr><td align="center">IS NULL</td><td align="center">为NULL值</td></tr></tbody></table><p>通配符</p><ol><li>like<ol><li>%通配符<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">'F%y'</span>;</span><br></pre></td></tr></table></figure></li><li>下划线(_)通配符</li><li>方括号([])——仅 <code>Access</code> 和 <code>SQL Server</code> 支持</li></ol></li></ol><blockquote><p>%匹配一个字符及以上;而下划线只能匹配一个字符。</p></blockquote><p>使用通配符技巧</p><ul><li>不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用<br>其他操作符。</li><li>在确实需要使用通配符时，也尽量不要把它们用在搜索模式的开始<br>处。把通配符置于开始处，搜索起来是最慢的。</li><li>仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。</li></ul>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring2_BeanBuilding</title>
      <link href="/2020/05/27/Spring2-BeanBuilding/"/>
      <url>/2020/05/27/Spring2-BeanBuilding/</url>
      
        <content type="html"><![CDATA[<p>装配Bean</p><a id="more"></a><h3 id="使用Spring容器"><a href="#使用Spring容器" class="headerlink" title="使用Spring容器"></a>使用Spring容器</h3><ol><li>maven配置；</li><li>创建Bean配置文件并定义好所需对象；</li><li>创建Spring容器并制定需要装载的Bean配置文件；</li><li>通过容器提供的方法获取容器中的对象来使用。</li></ol><h3 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h3><p><strong>什么是Bean？？</strong><br>Bean是一套约定或规范。具体的说Bean：<br>1、所有属性为private<br>2、提供默认构造方法<br>3、提供getter和setter<br>4、实现serializable接口</p><p>简单的说：由spring容器管理的对象都是Bean对象，也是普通的java对象。</p><blockquote><p>码两篇文章<a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&mid=2665513115&idx=1&sn=da30cf3d3f163d478748fcdf721b6414&scene=21#wechat_redirect" target="_blank" rel="noopener">【javaBean上】</a>、<a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&mid=2665513118&idx=1&sn=487fefb8fa7efd59de6f37043eb21799#rd" target="_blank" rel="noopener">【javaBean下】</a></p></blockquote><p><strong>Bean、EJB、POJO及区别</strong></p><ul><li>在java1996年发布,当年12月即发布了java bean1.00-A,有什么用呢?通过统一的规范可以设置对象的值(get,set方法),这是最初的java bean;</li><li>在实际企业开发中,需要实现事务、安全、分布式,javabean就不好用了.sun公司就开始往上面堆功能,这里java bean就复杂为EJB;</li><li>EJB功能强大,但是太重了.此时出现DI(依赖注入),AOP(面向切面)技术,通过简单的java bean也能完成EJB的事情,这里的java bean简化为POJO;</li><li>Spring诞生了.</li></ul><p>区别：先判断是否满足javabean的条件，然后如果再实现一些要求，满足EJB条件就是EJB，否则就是POJO。</p><h3 id="Spring支持三种方式配置Bean文件"><a href="#Spring支持三种方式配置Bean文件" class="headerlink" title="Spring支持三种方式配置Bean文件"></a>Spring支持三种方式配置Bean文件</h3><p>自动装配、java注解和xml配置（三种允许单独使用或混合使用）</p><h4 id="XML中的Bean配置"><a href="#XML中的Bean配置" class="headerlink" title="XML中的Bean配置"></a>XML中的Bean配置</h4><h5 id="bean定义"><a href="#bean定义" class="headerlink" title="bean定义"></a>bean定义</h5><ol><li>常见bean.xml内容</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans-4.3.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"引入其他bean xml配置文件"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean标识"</span> <span class="attr">class</span>=<span class="string">"玩转类型名称"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">"bean标识"</span> <span class="attr">alias</span>=<span class="string">"别名"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>bean命名</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean的唯一标识"</span> <span class="attr">name</span>=<span class="string">"bean的名称"</span> <span class="attr">class</span>=<span class="string">"完整类型名称"</span> <span class="attr">factory-bean</span>=<span class="string">"工厂bean名称"</span> <span class="attr">factory-method</span>=<span class="string">"工厂方法"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>bean名称别名定义规则<br>名称和别名可以通过bean元素中的id和name来定义，具体定义规则如下：：</p><ol><li>当id存在的时候，不管name有没有，取id为bean的名称；</li><li>当id不存在，此时需要看name，name的值可以通过<code>,;</code>或者<code>空格</code>分割，最后会按照分隔符得到一个String数组，数组的第一个元素作为bean的名称，其他的作为bean的别名；</li><li>当id和name都存在的时候，id为bean名称，name用来定义多个别名；</li><li>当id和name都不指定的时候，bean名称自动生成，生成为“完整类名 +#+编号。”eg:<code>com.hello#0</code>；</li></ol><p>alias元素也可以用来给某个bean定义别名，语法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">"需要定义别名的bean"</span> <span class="attr">alias</span>=<span class="string">"别名"</span> /&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>import——bean汇总</li></ol><p>在一个总的bean xml中对其他bean xml进行汇总，相当于把多个bean xml的内容合并到一个里，可以通过import元素引入其他bean配置文件。</p><p>在要汇总的bean.xml下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"其他配置文件的位置"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h5 id="容器创建bean实例"><a href="#容器创建bean实例" class="headerlink" title="容器创建bean实例"></a>容器创建bean实例</h5><ol><li>通过反射调用构造方法创建bean对象</li></ol><ol start="2"><li><p>通过静态工厂方法创建bean对象</p></li><li><p>通过实例工厂方法创建bean对象</p></li></ol><ol start="4"><li>通过FactoryBean创建bean对象</li></ol><h4 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h4><p>Spring从两个角度来实现自动化装配</p><ol><li>组件扫描：Spring自动发现应用上下文中所创建的Bean</li><li>自动装配：Spring自动满足Bean之间的依赖。</li></ol><h4 id="通过javaConfig显式配置"><a href="#通过javaConfig显式配置" class="headerlink" title="通过javaConfig显式配置"></a>通过javaConfig显式配置</h4><p>全程@Bean注解，通过return返回实例或进行DI配置。</p><h3 id="实践部分"><a href="#实践部分" class="headerlink" title="实践部分"></a>实践部分</h3><h4 id="创建一个Maven-projects并导入Spring-webmvc所需jar包"><a href="#创建一个Maven-projects并导入Spring-webmvc所需jar包" class="headerlink" title="创建一个Maven projects并导入Spring-webmvc所需jar包"></a>创建一个Maven projects并导入Spring-webmvc所需jar包</h4><ol><li>在IDEA中创建好基于Maven的project。</li><li>在pom.xml中导入依赖信息：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.17.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.17.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>注：</p><ol><li>直接导入这个包的原因是project项目可能需要的jar包特别多，且包之间还有依赖。直接导入一个集成的jar包，把依赖的包全自动下载了，能减少许多麻烦和问题。</li><li>记个坑：由于我的maven源使用的是阿里云的下载源，故有些jar包版本可能未及时更新，所以IDEA会显示 <code>Dependency &#39;org.springframework:spring-webmvc:5.2.6.RELEASE&#39; not found</code>。降低版本可能会解决。</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="http://www.itsoku.com/article/261" target="_blank" rel="noopener">Java干货铺子</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++(note)</title>
      <link href="/2020/05/25/C++/"/>
      <url>/2020/05/25/C++/</url>
      
        <content type="html"><![CDATA[<p>重载函数+函数模板</p><a id="more"></a><hr><p><strong>目录</strong></p><ul><li><a href="#c变量的存储期">一、C++变量的存储期</a></li><li><a href="#内置函数inline">二、内置函数</a></li><li><a href="#重载函数">三、重载函数</a></li><li><a href="#指针">四、指针和引用</a></li><li><a href="#枚举">五、枚举</a></li><li><a href="#函数模板template">六、函数模板</a></li><li><a href="#文件流">七、文件输入输出流</a></li></ul><h3 id="一、C-变量的存储期"><a href="#一、C-变量的存储期" class="headerlink" title="一、C++变量的存储期"></a>一、C++变量的存储期</h3><p>存储期，即变量在内存中的存储周期。其又可分为静态存储期和动态存储期。</p><p>静态存储方式：在程序运行中分配固定的空间，程序结束后释放。(static)<br>动态存储方式：在程序运行中动态的分配空间。(形参、变量、函数调用的保护和恢复现场等)</p><h4 id="C-变量的存储类别"><a href="#C-变量的存储类别" class="headerlink" title="C++变量的存储类别"></a>C++变量的存储类别</h4><p>四个类别：自动的（auto）、静态的（static）、寄存器的（register）、外部的（extern）。</p><ol><li>auto</li></ol><p>函数中的局部变量，不用static修饰，默认auto，即动态的分配存储空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="keyword">int</span> b,c;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>static</li></ol><p>局部变量定义为 static 时，系统分配静态空间，当变量调用结束时，保留原值而不释放空间，下次调用时该值依旧存在，且可以操作。</p><blockquote><p>与一般的auto变量的区别在于，被调用结束后空间不释放。静态变量仅<strong>在编译时赋值一次</strong>，以后再调用不再赋值。而auto变量随便赋值，每次都不保留。</p></blockquote><p>注：</p><ul><li>变量应该在定义时初始化，否则<strong>自动赋0或null</strong>。而auto是随机数。</li><li>在被一个函数调用结束后，虽然保留了原空间的值，但来自不同函数的调用是互相不可见的。即如果有另外一个函数调用它，又是一个全新的空间分配。</li></ul><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a=<span class="number">1</span>;   <span class="comment">//定义静态局部变量</span></span><br><span class="line">    a = a + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//输出 2;</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//输出 3;  //原变量值在上一次调用结束后保持不变。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>register(了解)</li></ol><p>背景：上述的变量都是存放在内存中的，而存取变量需要时间。当需要大量、频繁的调用某一变量时，选择使用CPU寄存器存取会更快（系统对寄存器的存取速度高于内存）。如此可以提高效率。</p><p>如今系统有自动选择是否寄存器。</p><ol start="4"><li>extern</li></ol><p>用于声明全局变量，扩展全局变量的作用域。</p><ol><li>同一个源文件下，例如：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> a,b;   <span class="comment">//（提前）引用全局变量 a,b</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">max</span>(a,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">16</span>, b=<span class="number">-7</span>; <span class="comment">//定义全局变量 a,b</span></span><br></pre></td></tr></table></figure></li><li>不同源文件下，两个文件使用同一个变量时，可以在一个文件中使用 extern 引用另一个文件定义好的变量。</li></ol><p>注:如果不想被外部文件引用可以使用 static修饰变量。</p><h3 id="二、内置函数——inline"><a href="#二、内置函数——inline" class="headerlink" title="二、内置函数——inline"></a>二、内置函数——inline</h3><p>内置函数，又称内联函数、内嵌函数。</p><p>背景：一般的程序执行并调用外部函数时，需要保存当前主调函数跳转去执行外部函数，需要保存现场，执行完后又需要恢复现场（即中断），如此是需要耗费时间的。为了节省时间，提高效率。C++的内置函数，是把函数放在主调函数中，和主调函数一起执行的。</p><p>具体实现：与一般的功能函数无异，仅在声明时需在开头加 <strong>inline</strong> 关键字。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：为了避免主调函数过长，仅建议规模小（很简单的功能函数）而使用频繁的函数作为内置函数。</p><h3 id="三、重载函数"><a href="#三、重载函数" class="headerlink" title="三、重载函数"></a>三、重载函数</h3><p>重载函数，即函数参数个数、参数类型和参数顺序三者中必须至少有一种不同，函数返回值可同可不同的同名函数。<br>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">( <span class="keyword">int</span> a, <span class="keyword">int</span> b )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">( <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">double</span> b ,<span class="keyword">float</span> c)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="四、带默认参数的函数"><a href="#四、带默认参数的函数" class="headerlink" title="四、带默认参数的函数"></a>四、带默认参数的函数</h3><ol><li><p>实参与形参的结合按从左至右的顺序，即有指定默认值得参数必须放在形参列表得最右端。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> c=<span class="number">10</span>, <span class="keyword">double</span> d)</span></span>; <span class="comment">//不可</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">double</span> d, <span class="keyword">int</span> c=<span class="number">10</span>)</span></span>; <span class="comment">//可</span></span><br></pre></td></tr></table></figure></li><li><p>一个函数不可以同时是重载函数又是有默认参数的函数。</p></li><li><p>在调用有默认参数函数前必须定义好默认参数。</p></li></ol><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针只是一个地址，为什么要定义基类型？？eg：<code>int *p;char *p;</code><br>答：<strong>不同的数据类型在计算机系统中的存储方式和所占字节数不同</strong>，而<strong>指针只是一个地址</strong>，只是指向某个存储空间，但是读取数据的时候读取多少呢？noone knows。这时，数据类型站出来了，<del>它说它知道</del> 已经知道不同的数据类型占不同大小的空间，所以用数据类型来定义指针，在读取的时候系统就能够知道要读取多少数据。</p><p><del>深入底层它不香吗？就这？？好好学微机和计组</del></p><h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="keyword">int</span> (*p)(<span class="keyword">int</span> ,<span class="keyword">int</span> );   <span class="comment">//(*p)的括号不能省略</span></span><br><span class="line">p=<span class="built_in">max</span>;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">int</span> a,b,m;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">m=p(a,b);</span><br></pre></td></tr></table></figure><h4 id="const指针"><a href="#const指针" class="headerlink" title="const指针"></a>const指针</h4><ol><li>指向常量的指针变量</li></ol><p>格式：<code>const 类型名 * 指针变量名</code></p><p>用指向常量的指针变量只是限制了通过指针变量改变它指向的对象的值。</p><h4 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h4><p>指针数组：即数组每个元素都是用来存指针的。<br>定义：类型名 * 数组名[数组长度]</p><p>eg：int * p[4];</p><p>合理利用，是个好东西。</p><p>小记：<code>p=&amp;array[i] //将数组array第i个元素的地址给p</code>.</p><h4 id="指针使用小结简记"><a href="#指针使用小结简记" class="headerlink" title="指针使用小结简记"></a>指针使用小结简记</h4><table><thead><tr><th align="center">变量定义</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">int *p[4]</td><td align="center">指针数组</td></tr><tr><td align="center">int (*p)[4]</td><td align="center">一般的数组，p是数组首地址的指针变量</td></tr><tr><td align="center">int * p()</td><td align="center">p为函数名，函数返回类型为int型地址</td></tr><tr><td align="center">int (*p)()</td><td align="center">p为指向函数的指针</td></tr><tr><td align="center">int **p</td><td align="center">指针的指针</td></tr><tr><td align="center">int const *p</td><td align="center">p是常指针，其值固定不变</td></tr><tr><td align="center">还有</td><td align="center">……</td></tr></tbody></table><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><strong>介绍</strong><br>c++引用，即引向一个已存在的对象。俗称“别名”，类似指针，但比指针受到的限制更多。</p><p>C++ 引用 vs 指针</p><ul><li>不存在空引用。引用必须连接到一块合法的内存。</li><li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。而指针可以在任何时候指向到另一个对象。</li><li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li></ul><p><strong>使用</strong></p><p>引用只有声明，没有定义。即先定义一个变量，然后声明一个引用去指代这个变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp; x, <span class="keyword">int</span> &amp; y )</span></span>&#123; <span class="comment">//定义引用</span></span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line">temp=x;</span><br><span class="line">x=y;</span><br><span class="line">y=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">23</span>,b=<span class="number">45</span>;</span><br><span class="line">swap(a,b);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">"\n"</span>&lt;&lt;b &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用还可作为返回值使用。</p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><pre><code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="keyword">enum</span> color&#123;red,yellow,blue,black&#125;;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">```c++</span><br><span class="line">color co1,co2;</span><br><span class="line">co1=red;</span><br><span class="line">co2=co1(<span class="number">2</span>);</span><br></pre></td></tr></table></figure></code></pre><p><del>使用次数=0</del></p><h3 id="函数模板——template"><a href="#函数模板——template" class="headerlink" title="函数模板——template"></a>函数模板——template</h3><p>函数模板，即建立一个通用函数，其函数类型和形参类型不具体指定，通过一个虚拟的类型来代表（也可称为泛型）。使用<strong>template</strong>关键词声明模板<br>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模板声明，T为类型参数。typename也可改写为 class.</span></span><br><span class="line"><span class="comment">//类型参数可以有多个 &lt;typename T1, typename T2&gt;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>与重载函数的区别：重载函数是一个函数名多个函数，可以相对地理解为单一功能函数；函数模板是一个函数名一个模板对应多个不同参数类型功能需求的函数，是一个通用函数。</p></blockquote><h2 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h2><p>在面向对象的程序设计中，除了主函数，其他的函数几乎都是出现在类里，通过类调用函数。程序的基本构成是类，程序面向的是类和对象。面向对象设计更利于开发更大规模的程序。</p><p>四个特点：抽象、封装、继承和多态性。</p><h3 id="类class"><a href="#类class" class="headerlink" title="类class"></a>类class</h3><blockquote><p>类是对象的抽象，即类是虚的，对象是实的。<br>类是设计图纸上的设计，对象是根据设计做出来的实物。</p></blockquote><p><strong>成员函数的代码不占用对象的存储空间</strong></p><ul><li>类的成员函数是公用的，即无论实例化了多少个对象，这些对象使用的函数都是相同的，公用的，并没有生成新的函数。</li><li>类的内存大小，取决于类中声明的成员变量，与成员函数无关。</li></ul><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><ol><li><p>同定义的一个类额多个对象之间可以相互赋值。如： <code>Time t1; Time t2=t1;</code></p></li><li><p>参数初始化表初始化数据成员</p></li></ol><p>格式：<code>类名::构造函数名([参数表])[:成员初始化表]{}</code> 。</p><pre><code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">width</span>;</span><br><span class="line">        <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Box(<span class="keyword">int</span> h, <span class="keyword">int</span> w, <span class="keyword">int</span> l):<span class="built_in">height</span>(h),<span class="built_in">width</span>(w),length(l)&#123;   <span class="comment">//使用参数初始化表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></code></pre><p><del>就是直接用成员变量自己赋值</del></p><ol start="3"><li><p>类的默认构造函数只有一个。可以是无参的构造函数或全指定了默认值的构造函数，二者不可同时出现，否则报错。</p></li><li><p>构造函数同样适用——上述 <a href="#四带默认参数的函数">带默认参数的函数</a></p></li></ol><h4 id="常对象-和-常对象成员"><a href="#常对象-和-常对象成员" class="headerlink" title="常对象 和 常对象成员"></a>常对象 和 常对象成员</h4><p><strong>常对象</strong></p><p>定义常对象 <code>类名 const 对象名（参数）;</code></p><p>将函数定义为常函数 <code>类型名 函数名()const;</code></p><ol><li>常对象只能调用它的常函数，普通函数不可；常对象可以正常调用常函数。</li><li>常函数可以访问常对象中的数据成员，但依旧不可以对它们进行修改。</li><li>常函数不可以调用非常函数</li></ol><blockquote><p>注：当常对象的某个变量确实需要修改时，可以使用 <code>mutable</code>关键字，则常函数就可以正常的修改它。</p></blockquote><p>在类中定义了常数据成员，则只能直接初始化或使用构造参数（通过参数初始化表）来初始化。</p><p>汇总小表</p><table><thead><tr><th align="center">数据成员</th><th align="center">非const的普通成员函数</th><th align="center">const成员函数</th></tr></thead><tbody><tr><td align="center">非const数据成员</td><td align="center">可以引用，也可以改变值</td><td align="center">可以引用但不可以改变值</td></tr><tr><td align="center">const数据成员</td><td align="center">可以引用，但不可以改变值</td><td align="center">可以引用，但不可以改变值</td></tr><tr><td align="center">const对象</td><td align="center">不允许引用</td><td align="center">可以引用但不可以改变值</td></tr></tbody></table><h4 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h4><p>被static修饰的成员。<br>静态成员是类层面的一部分。供类的其他函数和类的其他对象使用，是“公共”的。</p><p><strong>静态数据成员</strong></p><ol><li>静态数据成员可以初始化，但只能在类体外初始化，且不能用参数初始化表。</li><li>可以用类名引用静态数据成员，也可以通过对象来引用数据成员。</li></ol><p><strong>静态成员函数</strong></p><ol><li>在类外调用静态成员函数时要使用 <code>类名::函数名</code>。</li><li>静态成员函数没有this指针。即静态成员函数不可以访问非静态成员。</li></ol><h4 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h4><p>关键字 <code>friend</code> 。定义为 <code>friend</code> 的函数或类为友元函数或友元类。<br>友元的作用：突破private的壁垒，访问类的私有成员。</p><p>使用：想要使用某一个类的私有成员，在该类中声明用 <code>friend</code>声明一下即可。</p><p>例如普通函数声明为友元函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">width</span>;</span><br><span class="line">        <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Box(<span class="keyword">int</span> h, <span class="keyword">int</span> w, <span class="keyword">int</span> l):<span class="built_in">height</span>(h),<span class="built_in">width</span>(w),length(l)&#123;   <span class="comment">//使用参数初始化表</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Box &amp;b)</span></span>;<span class="comment">//声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(Box &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;b.<span class="built_in">height</span>&lt;&lt;<span class="string">"\t"</span>&lt;&lt;b.<span class="built_in">width</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Box <span class="title">b</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="built_in">display</span>(b);<span class="comment">//调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：其他如友元成员函数也是如此，只需将类名带上即可。</p></blockquote><h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><p>析构函数——清场人员，only one。</p><p>不反回任何值，没有函数类型，没有函数参数。</p><p><strong>使用</strong></p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">width</span>;</span><br><span class="line">        <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ~Box()&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>几个对象的构造函数和析构函数调用顺序：先构造的后析构，后构造的先析构。</p><h4 id="对象指针"><a href="#对象指针" class="headerlink" title="对象指针"></a>对象指针</h4><p>对象都可用指针。</p><p>对成员函数使用指针，函数返回值类型作为指针的定义类型。</p><p>使用格式：<code>&amp;类名::成员函数名</code>，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span>&#123;</span>……&#125;;</span><br><span class="line"><span class="keyword">void</span> Time::getTime()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>(Time:: *p)(); <span class="comment">//定义指向Time类的成员函数的指针变量p</span></span><br><span class="line">    p=&amp;Time::getTime;<span class="comment">//使p指向Time的函数getTime()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>这部分有点sao，pay attention。</del></p><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>运算符重载实质上是<strong>函数重载</strong>。其函数名就是 <code>operator 运算符</code>。其他与一般的函数一致。</p><p>大部分的运算符都能重载，除了这5个：<code>.</code> ， <code>*</code> ，<code>::</code> ，<code>sizeof</code>，<code>?:</code> 。</p><ol><li>运算符重载函数作为类的成员函数：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//简写</span></span><br><span class="line">Complex <span class="keyword">operator</span> + (Complex &amp;c2);</span><br><span class="line">Complex(<span class="keyword">int</span> a, <span class="keyword">int</span> b):real(a),imag(b)&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> real;</span><br><span class="line"><span class="keyword">int</span> imag; </span><br><span class="line">&#125;;</span><br><span class="line">Complex Complex::<span class="keyword">operator</span> +(Complex &amp;c2)&#123;</span><br><span class="line"><span class="keyword">return</span> Complex(real+c2.real,imag+c2.imag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>作为友元函数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//简写</span></span><br><span class="line"><span class="keyword">friend</span> Complex <span class="keyword">operator</span> + (Complex &amp;c2);</span><br><span class="line">Complex(<span class="keyword">int</span> a, <span class="keyword">int</span> b):real(a),imag(b)&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> real;</span><br><span class="line"><span class="keyword">int</span> imag; </span><br><span class="line">&#125;;</span><br><span class="line">Complex <span class="keyword">operator</span> +(Complex &amp;c1, Complex &amp;c2)&#123;</span><br><span class="line"><span class="keyword">return</span> Complex(c1.real+c2.real,c1.imag+c2.imag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="虚基类"><a href="#虚基类" class="headerlink" title="虚基类"></a>虚基类</h3><hr><h2 id="输入输出流（I-O-Stream）"><a href="#输入输出流（I-O-Stream）" class="headerlink" title="输入输出流（I/O Stream）"></a>输入输出流（I/O Stream）</h2><p>输入输出流：指若干个字节组成的字节序列，这些字节中的数据按顺序从一个对象传送到另一个对象。</p><p>包括标准I/O、文件I/O和串I/O。</p><h4 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h4><table><thead><tr><th align="center">数据类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">ofstream</td><td align="center">该数据类型表示输出文件流，用于创建文件并向文件写入信息。</td></tr><tr><td align="center">ifstream</td><td align="center">该数据类型表示输入文件流，用于从文件读取信息。</td></tr><tr><td align="center">fstream</td><td align="center">该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。</td></tr></tbody></table><p>头文件加&lt;fstream&gt;即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fstream"</span></span></span><br><span class="line"><span class="comment">// 创建输入文件对象</span></span><br><span class="line">ifstream infile;</span><br><span class="line">ofstream outfile;</span><br><span class="line">infile.<span class="built_in">open</span>(<span class="string">"myfile1.txt"</span>);</span><br><span class="line">outfile.<span class="built_in">open</span>(<span class="string">"myfile2.txt"</span>);</span><br><span class="line"><span class="keyword">float</span> x,y;</span><br><span class="line">infile&gt;&gt;x&gt;&gt;y;</span><br><span class="line">outfile&lt;&lt;x&lt;&lt;<span class="string">'\t'</span>&lt;&lt;y&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">infile.<span class="built_in">close</span>();</span><br><span class="line">outfile.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure><p>注：本篇作为学习和复习C++课程的笔记和要点，内容不全，有错还请指出。😀😀</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows系统相关知识</title>
      <link href="/2020/05/23/Windows%E7%B3%BB%E7%BB%9F/"/>
      <url>/2020/05/23/Windows%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>Windows系统</p><a id="more"></a><blockquote><p>因为要清理一下电脑，所以补点Windows下的电脑知识，记录笔记。</p></blockquote><h3 id="系统盘文件夹认识"><a href="#系统盘文件夹认识" class="headerlink" title="系统盘文件夹认识"></a>系统盘文件夹认识</h3><ol><li><p>PerfLogs——系统日志</p></li><li><p>Program files以及Program File（x86）——软件的安装目录。</p></li><li><p>Program Data——应用数据文件夹</p></li><li><p>windows——内含Windows系统运行的文件</p></li><li><p>用户——保存用户文件。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> ComputerBasic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSBasic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaSE-12.部署</title>
      <link href="/2020/05/20/javaSE-12-%E9%83%A8%E7%BD%B2/"/>
      <url>/2020/05/20/javaSE-12-%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<p>认识jar包</p><a id="more"></a><hr><h2 id="JAR文件"><a href="#JAR文件" class="headerlink" title="JAR文件"></a>JAR文件</h2><p>Java 归档（jar）文件：是压缩格式，文件内可以包含类文件、图像、声音和其他资源，另外包含一个用于描述归档特征的清单文件（manifest）。作用是将应用程序打包，发给使用者。</p><ol><li>创建jar文件</li></ol><p>jar工具制作JAR文件（在默认的JDK 安装中， 位于jdk/bin 目录下）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 操作命令格式</span></span><br><span class="line">jar options file1 file2 ……</span><br></pre></td></tr></table></figure><ol start="2"><li>jar清单文件（manifest）</li></ol><p>清单文件被命名为MANIFEST.MF, 它位于JAR 文件的一个特殊META-INF 子目录中。</p><ol start="3"><li>可执行jar文件</li></ol><p>用户可通过命令启动应用程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar filename.jar</span><br></pre></td></tr></table></figure><p>注：不同操作系统也可以通过不同方式启动应用程序</p><ol start="4"><li>资源</li></ol><p>不是源代码文件的其他文件都可以广义的成为资源（resource）。</p><ol start="5"><li>密封</li></ol><p>作用：密封可以保证不会有其他的类加入到其中。</p><p>创建jar包时，默认包时没有密封的。可在清单文件中设定打包时是否密封。</p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《java核心技术 卷一》</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> javaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA使用</title>
      <link href="/2020/05/20/IDEA%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/05/20/IDEA%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>IDEA小知识</p><a id="more"></a><p>前言：为了借助工具更好的学习，以及之前mentor说的出一篇IDEA的使用博文。这里补上，就随便记一部分，慢慢更、慢慢补。</p><h3 id="概念解释or介绍"><a href="#概念解释or介绍" class="headerlink" title="概念解释or介绍"></a>概念解释or介绍</h3><h4 id="IDEA不像Eclipse设置工作空间"><a href="#IDEA不像Eclipse设置工作空间" class="headerlink" title="IDEA不像Eclipse设置工作空间"></a>IDEA不像Eclipse设置工作空间</h4><p>IDEA不需要设置工作空间，因为每一个Project都具备一个工作空间！！对于每一个IDEA的项目工程（Project）而言，它的每一个子模块（Module）都可以使用独立的JDK和MAVEN配置。<br>每个新项目（Project）都需要设置自己的JDK和MAVEN等相关配置</p><p>Module</p><p>模块化的概念，作为聚合工程亦或普通的根目录，它称之为Project，而下面的子工程称为模块，每一个子模块之间可以相关联，也可以没有任何关联。</p><p>设置</p><p>设置里可以设置整个IDE的东西。主要要关注的是JDK和maven，可以设置全局默认配置，以后每一个project或者module就不用自己麻烦配置了。</p><p>注：maven插件给操作maven提供了极大便利。</p><p>版本控制Git/Svn（默认配置）<br>具体步骤：顶部工具栏  File -&gt;Other Settings -&gt; Default Settings -&gt; Version Control -&gt; Git</p><h3 id="编码常用技巧"><a href="#编码常用技巧" class="headerlink" title="编码常用技巧"></a>编码常用技巧</h3><ol><li>解决错误的万能快捷键alt+Enter</li></ol><p>具体操作：将光标移动到代码标红处然后按下alt+Enter。</p><ol start="2"><li>代码格式化Ctrl+alt+l。</li></ol><p>调整调整全篇代码的样式格式。</p><ol start="3"><li>全部重命名shift+f6</li></ol><p>写错或要修改：包名、类名、方法名、变量名……且被引用了的时候。<br>另外一个方法：1.光标定位；2.右键-重构-重命名；3.输入新名称后确定。</p><ol start="4"><li>Intellij IDEA十大快捷键</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><p><a href="https://www.jianshu.com/p/9c65b7613c30" target="_blank" rel="noopener">IntelliJ IDEA 使用教程(2019图文版) – 从入门到上瘾</a></p></li><li><p><a href="https://www.jb51.net/article/136761.htm" target="_blank" rel="noopener">Intellij IDEA十大快捷键</a></p></li><li><p><a href=""></a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring1</title>
      <link href="/2020/05/20/Spring1/"/>
      <url>/2020/05/20/Spring1/</url>
      
        <content type="html"><![CDATA[<p>Spring概念 + IOC + AOP</p><a id="more"></a><hr><p>学技术三大问：</p><ol><li><p>为什么学？</p></li><li><p>学有什么用？</p></li><li><p>怎么学？</p></li></ol><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><blockquote><p>基于《Spring实战》+ 网络教程</p></blockquote><h3 id="Spring容器（框架）"><a href="#Spring容器（框架）" class="headerlink" title="Spring容器（框架）"></a>Spring容器（框架）</h3><ul><li>定义：Spring是一个<strong>轻量级的、非入侵式的开源</strong>框架（容器）。</li><li>目标和使命：简化java开发，促进代码的松散耦合。</li></ul><p>spring容器的概念，容器可以放很多东西，程序启动的时候会创建spring容器，会给spring容器一个清单，清单中列出了需要创建的对象以及对象依赖关系，spring容器会创建和组装好清单中的对象，然后将这些对象存放在spring容器中，当程序中需要使用的时候，可以到容器中查找获取，然后直接使用。具有依赖注入功能的容器，负责对象的实例化、对象的初始化，对象和对象之间依赖关系配置、对象的销毁、对外提供对象的查找等操作，控制对象的整个生命周期。</p><h3 id="Spring核心"><a href="#Spring核心" class="headerlink" title="Spring核心"></a>Spring核心</h3><ol><li><p><strong>AOP（aspect-orientd programming）面向切面编程</strong>。</p></li><li><p><strong>IOC（Inversion of Control）：控制反转，是一种设计思想。IOC主要通过DI和DL来具体实现。</strong></p></li></ol><ul><li><strong>DI（Dependency Injection）：依赖注入</strong></li><li>DL（）：依赖查找</li></ul><ol start="3"><li>支持事务的处理，对框架整合的支持。</li></ol><p><strong>一句话：Spring是一个控制反转（IOC）和面向切面编程（AOP）的开源框架。</strong></p><p><a href="https://docs.spring.io/spring/docs/5.3.0-SNAPSHOT/spring-framework-reference/overview.html#overview" target="_blank" rel="noopener">Spring Framework官方文档介绍</a></p><blockquote><p>IOC和DI的区别？？<br>答：IOC是目的，DI是手段。IOC通过DI来实现（DL了解）。IOC是指让生成类的方式由传统方式（new）反过来，即程序员不调用new, 需要类的时候由框架注入（DI），是从不同层面的解读。——来自知乎高分答案</p></blockquote><p><a href="https://mp.weixin.qq.com/s/eNTIxzvXpPCDt6r5686Aiw" target="_blank" rel="noopener">IOC原理等着填:(转载)Spring IOC 知识点总结</a></p><h4 id="IOC控制反转"><a href="#IOC控制反转" class="headerlink" title="IOC控制反转"></a>IOC控制反转</h4><p>以前，程序员使用对象的时候都需要自己去创建和组装，而现在这些创建和组装都交给spring容器去给完成了，程序员只需要去spring容器中查找需要使用的对象就可以了；这个过程中对象的创建和组装过程被反转了，之前是使用者自己主动去控制的，现在交给spring容器去创建和组装了，对象的构建过程被反转了，所以叫做控制反转；</p><h4 id="DI-依赖注入"><a href="#DI-依赖注入" class="headerlink" title="DI 依赖注入"></a>DI 依赖注入</h4><p>依赖注入是spring容器中创建对象时给其设置依赖对象的方式，比如给spring一个清单，清单中列出了需要创建B对象以及其他的一些对象（可能包含了B类型中需要依赖对象），此时spring在创建B对象的时候，会看B对象需要依赖于哪些对象，然后去查找一下清单中有没有包含这些被依赖的对象，如果有就去将其创建好，然后将其传递给B对象；可能B需要依赖于很多对象，B创建之前完全不需要知道其他对象是否存在或者其他对象在哪里以及被他们是如何创建，而spring容器会将B依赖对象主动创建好并将其注入到B中去，比如spring容器创建B的时候，发现B需要依赖于A，那么spring容器在清单中找到A的定义并将其创建好之后，注入到B对象中。</p><h3 id="Spring-组成"><a href="#Spring-组成" class="headerlink" title="Spring 组成"></a>Spring 组成</h3><p><a href="https://cdn.jsdelivr.net/gh/MrGo123/asset@master/sourceinpost/java/SpringConsist.png" target="_blank" rel="noopener"></a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.itsoku.com/article/259" target="_blank" rel="noopener">路人甲java——《Spring系列第2篇：控制反转（IoC）与依赖注入（DI）》</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat</title>
      <link href="/2020/05/19/Tomcat/"/>
      <url>/2020/05/19/Tomcat/</url>
      
        <content type="html"><![CDATA[<p>Tomcat基本信息+Tomcat配置</p><a id="more"></a><hr><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Tomcat简单的说就是一个运行JAVA的网络服务器，底层是Socket的一个程序，它也是JSP和Serlvet的一个容器。</p><h2 id="一、Tomcat三个功能："><a href="#一、Tomcat三个功能：" class="headerlink" title="一、Tomcat三个功能："></a>一、Tomcat三个功能：</h2><ol><li>Web服务器</li><li>jsp容器</li><li>Servlet容器。</li></ol><h2 id="二、Tomcat文件目录介绍"><a href="#二、Tomcat文件目录介绍" class="headerlink" title="二、Tomcat文件目录介绍"></a>二、Tomcat文件目录介绍</h2><p><img src="https://cdn.jsdelivr.net/gh/MrGo123/asset@master/sourceinpost/java/TomcatFileInfo.png" alt=""></p><p>注，重点说明：</p><ol><li><strong>conf目录</strong>：</li></ol><ul><li>server.xml 文件用于配置server相关信息；</li><li>web.xml 文件配置与web应用（一个web应用相当于一个web站点）</li><li>tomcat-user.xml 配置用户名密码及相关权限。</li></ul><ol start="2"><li><p><strong>work目录</strong>：<br>用于存放jsp被访问后生成的对应的server文件和.class文件</p></li><li><p><strong>webapps目录</strong>：</p></li></ol><ul><li>存放web应用。</li><li>使用：在webapps目录下新建文件夹（内包含.html、WEB-INF、jsp、图片等文件），用于存放web应用<blockquote><p>WEB-INF目录用于对web应用做设置、调整等。主要是<strong>web.xml</strong>配置文件的配置使用。</p></blockquote></li></ul><p><strong>一个web应用的目录结构：</strong><br><img src="https://cdn.jsdelivr.net/gh/MrGo123/asset@master/sourceinpost/java/Awebapp.png" alt=""></p><h2 id="三、配置虚拟目录"><a href="#三、配置虚拟目录" class="headerlink" title="三、配置虚拟目录"></a>三、配置虚拟目录</h2><p>虚拟目录：一个<strong>映射</strong>，把分放在其他磁盘的web应用映射到webapps目录下。即记录指向其他web应用的路径，使得在要访问时，Tomcat能够找到它并运行。</p><blockquote><p>默认只有在webapps目录下的web应用才能被Tomcat自动管理成一个web站点。</p></blockquote><ol><li>法一：在Tomcat的conf/server.xml文件中<strong>添加</strong>如下代码<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># path表示的是访问时输入的web项目名，docBase表示的是站点目录的绝对路径。</span><br><span class="line"># 下例的代码背景：名称为 Demo1 的web应用放在D盘下</span><br><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">"/Demo1"</span> <span class="attr">docBase</span>=<span class="string">"D:\Demo1"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li>法二：到conf\Catalina\localhost文件下，创建一个xml文件，<strong>该文件的名字就是站点的名字</strong>。<code>.xml</code>文件内容如下<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="9.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Context</span></span></span><br><span class="line"><span class="tag">        <span class="attr">docBase</span>=<span class="string">"D:\Demo1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">reloadable</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="四、配置临时域名"><a href="#四、配置临时域名" class="headerlink" title="四、配置临时域名"></a>四、配置临时域名</h2><p><strong>访问Tomcat服务器的几种方式：</strong></p><ol><li>使用<code>localhost</code>域名访问</li><li>使用ip地址<code>127.0.0.1</code>访问【该ip地址也是本机】</li><li>使用主机名访问【只限于本机上或局域网】<a href="https://qastack.cn/unix/16890/how-to-make-a-machine-accessible-from-the-lan-using-its-hostname" target="_blank" rel="noopener">#？？？我还不懂？？？答：内网DNS解析#</a></li><li>使用本机IP地址访问【在cmd中输入ipconfig可以查询到本机的IP地址】</li><li>为机器配置临时域名</li></ol><p><strong>配置临时域名</strong></p><ol><li>到 C:\Windows\System32\drivers\etc下，找到hosts文件</li><li>添加、保存如下，然后即可通过<a href="http://hellozyhost访问本机了。" target="_blank" rel="noopener">http://hellozyhost访问本机了。</a></li></ol><p><img src="https://cdn.jsdelivr.net/gh/MrGo123/asset@master/sourceinpost/java/hostnametest.png" alt=""></p><blockquote><p>说到底是使用本机的DNS解析</p></blockquote><h2 id="五、设置虚拟主机"><a href="#五、设置虚拟主机" class="headerlink" title="五、设置虚拟主机"></a>五、设置虚拟主机</h2><p>虚拟主机：<strong>多个</strong>不同域名的网站共存在一个Tomcat中。<br>即：一个主机的情况下，一个Tomcat只能运行一个网站。如果我不配置虚拟主机，那么我需要多个电脑中的Tomcat来运行每一个域名的网站。</p><p><strong>配置虚拟主机</strong><br>在tomcat的server.xml文件中添加主机名</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"zy"</span> <span class="attr">appBase</span>=<span class="string">"D:\Demo1"</span>&gt;</span>                   </span><br><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">"/Demo1"</span> <span class="attr">docBase</span>=<span class="string">"D:\Demo1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br></pre></td></tr></table></figure><p>???????我怎么设置虚拟主机呢？？？？？？？</p><h2 id="六、Tomcat体系结构"><a href="#六、Tomcat体系结构" class="headerlink" title="六、Tomcat体系结构"></a>六、Tomcat体系结构</h2><p><img src="https://cdn.jsdelivr.net/gh/MrGo123/asset@master/sourceinpost/java/tomcatStructor.png" alt=""></p><h2 id="七、web访问流程"><a href="#七、web访问流程" class="headerlink" title="七、web访问流程"></a>七、web访问流程</h2><p><img src="https://cdn.jsdelivr.net/gh/MrGo123/asset@master/sourceinpost/java/webRoute.png" alt=""></p><h2 id="来源和参考"><a href="#来源和参考" class="headerlink" title="来源和参考"></a>来源和参考</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484755&idx=2&sn=b09e747bd0af5e1899a47911f92d1afe&chksm=ebd74452dca0cd44ebbcdacab7373a72d0c769746eaa2bfa454d1dbc8295e3f93b0645c0ac58###rd" target="_blank" rel="noopener">3y——《Tomcat就是这么简单》</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http</title>
      <link href="/2020/05/19/http/"/>
      <url>/2020/05/19/http/</url>
      
        <content type="html"><![CDATA[<p>基于《图解http》的阅读笔记<br>ps：没有笔记+不用=没学</p><a id="more"></a><hr><h3 id="Part1——-Web及网络基础"><a href="#Part1——-Web及网络基础" class="headerlink" title="Part1—— Web及网络基础"></a>Part1—— Web及网络基础</h3><p>3 项 <code>WWW（简称Web）</code> 构建技术，分别是：</p><ul><li>把 SGML（Standard Generalized Markup Language，标准通用标记语言）作为页面的文本标记语言的 HTML（HyperText Markup Language，超文本标记语言）；</li><li>作为文档传递协议的 HTTP ；</li><li>指定文档所在地址的 URL（Uniform Resource Locator，统一资源定位符）。 </li></ul><p>不同的硬件、操作系统之间的通信，都需要一种规则。这种规则称为<strong>协议（protocol）</strong>。<code>TCP/IP</code> 是互联网相关的各类协议族的总称。</p><h4 id="TCP-IP的分层"><a href="#TCP-IP的分层" class="headerlink" title="TCP/IP的分层"></a>TCP/IP的分层</h4><p>四层：应用层、传输层、网络层、和数据链路层。</p><blockquote><p>分层的一些好处：1.分层即把整体部分化，当有某个地方出现问题时不必改一个大整体，可以只改出现问题的一小部分。2.简化设计。</p></blockquote><ol><li><strong>应用层</strong></li></ol><p>应用层决定了向用户提供应用服务时通信的活动。</p><p>TCP/IP 协议族内预存了各类通用的应用服务。比如，FTP（File Transfer Protocol，文件传输协议）和 DNS（Domain Name System，域名系统）服务就是其中两类。</p><p><strong>HTTP 协议处于该层</strong>。</p><ol start="2"><li><strong>传输层</strong> </li></ol><p>传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。 </p><p>在传输层有两个性质不同的协议：<strong>TCP(Transmission Control Protocol，传输控制协议)</strong> 和 UDP（User Data Protocol，用户数据报协议）。 </p><ol start="3"><li><strong>网络层（又名网络互连层）</strong></li></ol><p>网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径 （所谓的传输路线）到达对方计算机，并把数据包传送给对方。 </p><p>与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一 条传输路线。 </p><ol start="4"><li><strong>链路层（又名数据链路层，网络接口层）</strong></li></ol><p>用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范 畴均在链路层的作用范围之内。 </p><!-- 这里缺一个TCP/IP通信传输流（封装）的流程图 --><p>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在 层与层传输数据时，每经过一层时会把对应的首部消去。 这种把数据信息包装起来的做法称为封装（encapsulate）。</p><h4 id="与http关系密切的协议：IP、TCP、DNS"><a href="#与http关系密切的协议：IP、TCP、DNS" class="headerlink" title="与http关系密切的协议：IP、TCP、DNS"></a>与http关系密切的协议：IP、TCP、DNS</h4><h5 id="1-负责传输的-IP"><a href="#1-负责传输的-IP" class="headerlink" title="1.负责传输的 IP"></a>1.负责传输的 IP</h5><p><strong>IP（Internet Protocol）</strong> 网际协议,位于网络层，也即TCP/IP 协议族中的 IP。作用是把各种数据包传送给对方。</p><blockquote><p>tips：此<code>IP</code>是一种协议的名称，需要与<code>IP地址</code>区别开。</p></blockquote><p>IP传送条件：IP 地址（指明了节点被分配到的地址），MAC 地址（指网卡所属的固定地址）。</p><h5 id="2-负责保障的-TCP"><a href="#2-负责保障的-TCP" class="headerlink" title="2.负责保障的 TCP"></a>2.负责保障的 TCP</h5><p><strong>TCP</strong> 位于传输层，提供<strong>可靠</strong>的<strong>字节流服务</strong>。即TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够确认数据最终是否送达到 对方。 </p><p>TCP的 <strong>三次握手</strong></p><p>用 TCP 协议把数据包送出去后，TCP 不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。 握手过程中使用了 TCP 的标志（ﬂag） —— SYN（synchronize） 和 ACK（acknowledgement）。 </p><p>发送端首先发送一个带 SYN 标志的数据包给对方。<code>（一次）</code> 接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。<code>(两次)</code> 最后，发送端再回传一个带 ACK 标志的数据包，<code>（三次）</code> 代表“握手”结束。</p><h5 id="3-负责域名解析的-DNS"><a href="#3-负责域名解析的-DNS" class="headerlink" title="3.负责域名解析的 DNS"></a>3.负责域名解析的 DNS</h5><p>DNS（Domain Name System），提供域名到 IP 地址之间的解析服务。位于应用层。</p><p>DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。</p><h4 id="URI和URL"><a href="#URI和URL" class="headerlink" title="URI和URL"></a>URI和URL</h4><ul><li><p>URL（Uniform Resource Locator，统一资源<strong>定位符</strong>）</p></li><li><p>URI（Uniform Resource Identiﬁer，统一资源<strong>标识符</strong>）</p></li></ul><p>Uniform 规定统一的格式可方便处理多种不同类型的资源，而不用根据上下文环境来识别资源指定的访问方式。另 外，加入新增的协议方案（如 http: 或 ftp:）也更容易。 </p><p>Resource 资源的定义是“可标识的任何东西”。除了文档文件、图像或服务（例如当天的天气预报）等能够区别于其 他类型的，全都可作为资源。另外，资源不仅可以是单一的，也可以是多数的集合体。 </p><p>Identiﬁer 表示可标识的对象。也称为标识符。综上所述，URI 就是由某个协议方案表示的资源的定位标识符。协议方案是指访问资源所使用的协议类型名称。 </p><p>URL 是 URI 的子集。 </p><hr><h3 id="Part2——-http协议"><a href="#Part2——-http协议" class="headerlink" title="Part2—— http协议"></a>Part2—— http协议</h3><h4 id="一-用于客户端和服务器之间的通信。"><a href="#一-用于客户端和服务器之间的通信。" class="headerlink" title="一 用于客户端和服务器之间的通信。"></a>一 用于客户端和服务器之间的通信。</h4><h4 id="二-通过请求和响应的交换达成通信（报文）。"><a href="#二-通过请求和响应的交换达成通信（报文）。" class="headerlink" title="二 通过请求和响应的交换达成通信（报文）。"></a>二 通过请求和响应的交换达成通信（报文）。</h4><h4 id="三-不保存状态的协议。"><a href="#三-不保存状态的协议。" class="headerlink" title="三 不保存状态的协议。"></a>三 不保存状态的协议。</h4><h4 id="四-请求由URI定位的资源。"><a href="#四-请求由URI定位的资源。" class="headerlink" title="四 请求由URI定位的资源。"></a>四 请求由URI定位的资源。</h4><h4 id="五-告知服务器意图的-HTTP方法。"><a href="#五-告知服务器意图的-HTTP方法。" class="headerlink" title="五 告知服务器意图的 HTTP方法。"></a>五 告知服务器意图的 HTTP方法。</h4><p><strong>HTTP方法：</strong></p><ol><li><code>GET</code>：获取资源<br>GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器端解析后返回响应内容。</li></ol><ol start="2"><li><code>POST</code>：传输实体主体<br>POST 方法用来传输实体的主体。与GET的差别在于POST主要目的不是<strong>获取</strong>响应的主体内容。</li></ol><ol start="3"><li><code>PUT</code>：传输文件<br>PUT 方法用来传输文件。就像 FTP 协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后 保存到请求 URI 指定的位置。 </li></ol><ol start="4"><li><code>HEAD</code>：获得报文首部<br>HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时 间等。</li></ol><ol start="5"><li><code>DELETE</code>：删除文件<br>DELETE 方法用来删除文件，是与 PUT 相反的方法。DELETE 方法按请求 URI 删除指定的资源。</li></ol><ol start="6"><li><code>OPTIONS</code>：询问支持的方法<br>OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。</li></ol><ol start="7"><li><code>TRACE</code>：追踪路径<br>TRACE 方法是让 Web 服务器端将之前的请求通信环回给客户端的方法。 </li></ol><ol start="8"><li><code>CONNECT</code>：要求用隧道协议连接代理<br>CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议 把通信内容加 密后经网络隧道传输。 </li></ol><h4 id="六-持久连接节省通信量（持久连接、管线化）"><a href="#六-持久连接节省通信量（持久连接、管线化）" class="headerlink" title="六 持久连接节省通信量（持久连接、管线化）"></a>六 持久连接节省通信量（持久连接、管线化）</h4><h4 id="七-使用-Cookie-的状态管理"><a href="#七-使用-Cookie-的状态管理" class="headerlink" title="七 使用 Cookie 的状态管理"></a>七 使用 Cookie 的状态管理</h4><p>Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 请求报文（没有 Cookie 信息的状态）-&gt; </span><br><span class="line">2. 响应报文（服务器端生成 Cookie 信息）-&gt; </span><br><span class="line">3. 请求报文（自动发送保存着的 Cookie 信息）</span><br></pre></td></tr></table></figure><hr><h3 id="Part3——-http报文内的http信息"><a href="#Part3——-http报文内的http信息" class="headerlink" title="Part3—— http报文内的http信息"></a>Part3—— http报文内的http信息</h3><h4 id="http报文"><a href="#http报文" class="headerlink" title="http报文"></a>http报文</h4><p>用于 HTTP 协议交互的信息被称为 HTTP 报文。请求端（客户端）的 HTTP 报文叫做请求报文，响应端 （服务器端）的叫做响应报文。HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本。 HTTP 报文大致可分为报文首部和报文主体两块。通常，并不一定要有报文主体。</p><p>报文（message）<br>是 HTTP 通信中的基本单位，由 8 位组字节流（octet sequence，其中 octet 为 8 个比 特）组成，通过 HTTP 通信传输。 </p><p>实体（entity）<br>作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成。 </p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li><p>请求报文及响应报文的结构</p></li><li><p>编码提升传输速率 </p></li><li><p>发送多种数据的多部分对象集合</p></li><li><p>获取部分内容的范围请求</p></li><li><p>内容协商返回最合适的内容 </p></li></ul><hr><h3 id="Part4——返回结果的HTTP状态码"><a href="#Part4——返回结果的HTTP状态码" class="headerlink" title="Part4——返回结果的HTTP状态码"></a>Part4——返回结果的HTTP状态码</h3><p>HTTP 状态码负责表示客户端 HTTP 请求的返回结果、标记服务器端的处理是否正常、通知出现的错误等工作。比如404。</p><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。</p><p>状态码类别：<br>|  状态码  | 类别 | 原因短语 |<br>|:–:| :–: | :–:    |<br>|1XX |Informational（信息性状态码） |接收的请求正在处理|<br>|2XX |Success（成功状态码） |请求正常处理完毕 |<br>|3XX |Redirection（重定向状态码） |需要进行附加操作以完成请求 |<br>|4XX |Client Error（客户端错误状态码） |服务器无法处理请求 |<br>|5XX |Server Error（服务器错误状态码） |服务器处理请求出错 |</p><h4 id="1-2XX-成功"><a href="#1-2XX-成功" class="headerlink" title="1) 2XX 成功"></a>1) 2XX 成功</h4><p>2XX 的响应结果表明请求被正常处理了。</p><ul><li><p><strong>200 OK</strong>：表示从客户端发来的请求在服务器端被正常处理了。 </p></li><li><p><strong>204 No Content</strong>：请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。</p></li><li><p><strong>206 Partial Content</strong>：表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。</p></li></ul><h4 id="2-3XX-重定向"><a href="#2-3XX-重定向" class="headerlink" title="2) 3XX 重定向"></a>2) 3XX 重定向</h4><p>3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。 </p><ul><li><p><strong>301 Moved Permanently</strong>：永久性重定向，表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。</p></li><li><p><strong>302 Found</strong>：临时性重定向，表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。 </p></li><li><p><strong>303 See Other</strong>：表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。 </p></li><li><p><strong>304 Not Modiﬁed</strong>：表示客户端发送附带条件的请求 2 时，服务器端允许请求访问资源，但未满足条件的情况。</p></li><li><p><strong>307 Temporary Redirect</strong>：临时重定向。该状态码与 302 Found 有着相同的含义。尽管 302 标准禁止 POST 变换成 GET，但实际使用时大家并不遵守。307 会遵照浏览器标准，不会从 POST 变成 GET。但是，对于处理响应时的行为，每种浏览器有可能出现不同的情况。</p></li></ul><h4 id="3-4XX-客户端错误"><a href="#3-4XX-客户端错误" class="headerlink" title="3) 4XX 客户端错误"></a>3) 4XX 客户端错误</h4><p>4XX 的响应结果表明客户端是发生错误的原因所在。 </p><ul><li><p><strong>400 Bad Request</strong>：表示请求报文中存在语法错误。另外，浏览器会像 200 OK 一样对待该状态码。 </p></li><li><p><strong>401 Unauthorized</strong>：表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。另外若之前已进行过 1 次请求，则表示用户认证失败。 </p></li><li><p><strong>403 Forbidden</strong>：表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。 </p></li><li><p><strong>404 Not Found</strong>：表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。</p></li></ul><h4 id="4-5XX-服务器错误"><a href="#4-5XX-服务器错误" class="headerlink" title="4) 5XX 服务器错误"></a>4) 5XX 服务器错误</h4><p>5XX 的响应结果表明服务器本身发生错误。 </p><ul><li><p><strong>500 Internal Server Error</strong>：表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。</p></li><li><p><strong>503 Service Unavailable</strong>：表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</p></li></ul><hr><h3 id="Part5——-与-HTTP-协作的-Web-服务器"><a href="#Part5——-与-HTTP-协作的-Web-服务器" class="headerlink" title="Part5—— 与 HTTP 协作的 Web 服务器"></a>Part5—— 与 HTTP 协作的 Web 服务器</h3><p>一台 Web 服务器可搭建多个独立域名的 Web 网站，也可作为通信路径上的中转服务器提升传输效率。</p><h4 id="用单台虚拟主机实现多个域名"><a href="#用单台虚拟主机实现多个域名" class="headerlink" title="用单台虚拟主机实现多个域名"></a>用单台虚拟主机实现多个域名</h4><p>HTTP/1.1 规范允许一台 HTTP 服务器搭建多个 Web 站点</p><p>在互联网上，域名通过 DNS 服务映射到 IP 地址（域名解析）之后访问目标网站。可见，当请求发送到 服务器时，已经是以 IP 地址形式访问了。 所以，如果一台服务器内托管了 <a href="http://www.tricorder.jp" target="_blank" rel="noopener">www.tricorder.jp</a> 和 <a href="http://www.hackr.jp" target="_blank" rel="noopener">www.hackr.jp</a> 这两个域名，当收到请求时就需要 弄清楚究竟要访问哪个域名。</p><p>在相同的 IP 地址下，由于虚拟主机可以寄存多个不同主机名和域名的 Web 网站，因此在发送 HTTP 请求时，必须在 Host 首部内完整指定主机名或域名的 URI。？？？</p><h4 id="通信数据转发程序-：代理、网关、隧道"><a href="#通信数据转发程序-：代理、网关、隧道" class="headerlink" title="通信数据转发程序 ：代理、网关、隧道"></a>通信数据转发程序 ：代理、网关、隧道</h4><h5 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h5><p>代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“<strong>中间人</strong>”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。代理不改变请求 URI，会直接发送给前方持有资源的目标服务器。 </p><blockquote><p>持有资源实体的服务器被称为源服务器</p></blockquote><p>代理有多种使用方法，按两种基准分类。一种是是否使用缓存，另一种是是否会修改报文。</p><ol><li><p><strong>缓存代理</strong><br>代理转发响应时，缓存代理（Caching Proxy）会预先将资源的副本（缓存）保存在代理服务器上。 </p></li><li><p><strong>透明代理</strong><br>转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理（Transparent Proxy）。反之，对报文内容进行加工的代理被称为非透明代理。 </p></li></ol><h5 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h5><p>网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关。 </p><p>利用网关可以由 HTTP 请求转化为其他协议通信<br>利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。</p><h5 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h5><p>隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。<br>目的是确保客户端能与服务器进行安全的通信。<br>隧道可按要求建立起一条与其他服务器的通信线路，届时使用 SSL 等加密手段进行通信。</p><h5 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h5><p>缓存是指在代理服务器或客户端本地磁盘内保存的资源副本。</p><ul><li>缓存代理服务器能向原服务器确认缓存有效性进而判别缓存内容是否过期。</li><li>在客户端（浏览器）缓存称为临时网络文件。过期后也会向代理服务器确认有效性。</li></ul><h3 id="Part6——HTTP首部"><a href="#Part6——HTTP首部" class="headerlink" title="Part6——HTTP首部"></a>Part6——HTTP首部</h3><p>HTTP 协议的请求和响应报文中必定包含 HTTP 首部。首部内容为客户端和服务器分别处理请求和响应提 供所需要的信息。</p><!-- 太多太重点了 --><h3 id="Part7——确保安全的https"><a href="#Part7——确保安全的https" class="headerlink" title="Part7——确保安全的https"></a>Part7——确保安全的https</h3><p>HTTP 主要有这些不足，例举如下。</p><ol><li>通信使用明文（不加密），内容可能会被窃听</li></ol><p>HTTP 协议中没有加密机制</p><p>加密</p><ul><li><p>通信加密<br>SSL（Secure Socket Layer，安全套接层）或 TLS（Transport Layer Security，安全层传输协议）的组合使用，加密 HTTP 的通信内容。与 SSL 组合使用的 HTTP 被称为 <strong>HTTPS（HTTP Secure，超文本传输安全协议）</strong>或 HTTP over SSL。</p></li><li><p>内容加密<br>对 HTTP 协议传输的内容本身加密。即把 HTTP 报文里所含的内容进行加密处理</p></li></ul><ol start="2"><li>不验证通信方的身份，因此有可能遭遇伪装 </li></ol><ul><li>由于不存在确认通信方的处理步骤，任何人都可发起请求，服务器也都会有回应（除非其端口限制）。</li></ul><blockquote><ol><li>无法确定请求发送至目标的 Web 服务器是否是按真实意图返回响应的那台服务器。有&gt; 可能是已伪装的 Web 服务器。 </li><li>无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已&gt; 伪&gt; 装的客户端。 </li><li>无法确定正在通信的对方是否具备访问权限。因为某些 Web 服务器<br>上保存着重要的信息，只想发给特定用户通信的权限。</li><li>无法判定请求是来自何方、出自谁手。 </li><li>即使是无意义的请求也会照单全收。无法阻止海量请求下的 DoS 攻击 （Denial of &gt; Service，拒绝服务攻击）。 </li></ol></blockquote><ul><li>查明对手的证书 </li></ul><p>SSL 不仅提供加密处理，而且还使用了一种被称为证书的手段，可用于确定方。</p><p>客户端持有证书即可完成个人身份的确认，也可用于对 Web 网站的认证环节。 </p><ol start="3"><li>无法证明报文的完整性，所以有可能已遭篡改</li></ol><p>HTTP 协议无法证明通信的报文完整性，没有任何办法确认，发出的请求 / 响应和接收到的请求 / 响应是前后相同的。</p><blockquote><p>即在传输过程中被遭攻击者拦截并篡改内容的攻击称为<strong>中间人攻击</strong>（Manin-the-Middle attack，MITM）&gt; 但两端通信看上去还是正常的。</p></blockquote><h4 id="HTTP-加密-认证-完整性保护-HTTPS（HTTP-Secure）"><a href="#HTTP-加密-认证-完整性保护-HTTPS（HTTP-Secure）" class="headerlink" title="HTTP+加密+认证+完整性保护=HTTPS（HTTP Secure）"></a>HTTP+加密+认证+完整性保护=HTTPS（HTTP Secure）</h4><p>HTTPS并非是应用层的一种新协议。是 HTTP 通信接口部分用 SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替。</p><p>HTTP:</p><table><thead><tr><th align="center">应用（HTTP）</th></tr></thead><tbody><tr><td align="center">TCP</td></tr><tr><td align="center">IP</td></tr></tbody></table><p>HTTPS:</p><table><thead><tr><th align="center">应用（HTTP）</th></tr></thead><tbody><tr><td align="center">SSL</td></tr><tr><td align="center">TCP</td></tr><tr><td align="center">IP</td></tr></tbody></table><blockquote><p>SSL 是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在应用层的 SMTP 和 Telnet 等协议均可配合 SSL 协议使用。可以说 SSL 是当今世界上应用最为广泛的网络安全技术。 </p></blockquote><p><strong>公开密钥加密技术</strong></p><p>SSL 采用一种叫做<strong>公开密钥加密（Public-key cryptography）</strong>的加密处理方式。<br>加密和解密都会用到密钥。任何人只要持有密钥就能解密。（共享密钥加密的弊端）</p><p>公开密钥加密使用一对<strong>非对称</strong>的密钥。一把叫做私有密钥（private key），另一把叫做公开密钥（public key）。顾名思义，私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。 使用公开密钥加密方式，发送密文的一方使用对方的<strong>公开密钥进行加密处理</strong>，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。 </p><p>HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密机制。</p><p>若密钥能够实现安全交换，那么有可能会考虑仅使用公开密钥加密来通信。但是公开密钥加密与共享密钥加密相比，其<strong>处理速度要慢</strong>。 </p><p>所以应充分利用两者各自的优势，将多种方法组合起来用于通信。<strong>在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式。</strong>（即先给安全的给密钥对方，后面的通信就可以安全使用共享加密）</p><p>另一个层次：公开密钥可能是假的，亦会造成信息泄露。<br>解决方法：由数字证书机构颁发<strong>公开密钥证书</strong>（简称数字证书或证书）。</p><blockquote><p>数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。</p></blockquote><p>证书的一个作用是用来证明作为通信一方的服务器是否规范，另外一个作用是可确认对方服务器背后运营的企业是否真实存在。拥有该特性的证书就是 EV SSL 证书（Extended Validation SSL Certiﬁcate）。</p><h3 id="Part8——确认访问用户身份的认证"><a href="#Part8——确认访问用户身份的认证" class="headerlink" title="Part8——确认访问用户身份的认证"></a>Part8——确认访问用户身份的认证</h3><p>访问用户身份认证就是要确定访问的人是不是网页指定的允许的人。</p><p>HTTP/1.1使用的认证方式：</p><ol><li>BASIC认证(基本认证)</li><li>DIGEST认证(摘要认证)</li><li>SSL客户端认证</li><li>FormBase认证(基于表单认证)</li></ol><ol><li>BASIC认证</li></ol><p>可以认为是简单的填写用户名和密码认证。<br>具体实现：</p><p>步骤 1： 当请求的资源需要 BASIC 认证时，服务器会随状态码 401 Authorization Required，返回带 WWW-Authenticate 首部字段的响应。该字段内包含认证的方式（BASIC） 及 Request-URI 安全域字 符串（realm）。<br>步骤 2： 接收到状态码 401 的客户端为了通过 BASIC 认证，需要将用户 ID 及密码发送给服务器。发 送的字符串内容是由用户 ID 和密码构成，两者中间以冒号（:）连接后，再经过 Base64 编码处理。 假设用户 ID 为 guest，密码是 guest，连接起来就会形成 guest:guest 这样的字符串。然后经过 Base64 编码，最后的结果即是 Z3Vlc3Q6Z3Vlc3Q=。把这串字符串写入首部字段 Authorization 后，发送请求。 当用户代理为浏览器时，用户仅需输入用户 ID 和密码即可，之后，浏览器会自动完成到 Base64 编码的 转换工作。<br>步骤 3： 接收到包含首部字段 Authorization 请求的服务器，会对认证信息的正确性进行验证。如验证 通过，则返回一条包含 Request-URI 资源的响应。<br>BASIC 认证虽然采用 Base64 编码方式，但这不是加密处理。不需要任何附加信息即可对其解码。换言 之，由于明文解码后就是用户 ID 和密码，在 HTTP 等非加密通信的线路上进行 BASIC 认证的过程中， 如果被人窃听，被盗的可能性极高。<br>另外，除此之外想再进行一次 BASIC 认证时，一般的浏览器却无法实现认证注销操作，这也是问题之 一。<br>BASIC 认证使用上不够便捷灵活，且达不到多数 Web 网站期望的安全性等级，因此它并不常用。</p><ol start="2"><li>DIDEST认证</li></ol><h3 id="扩展阅读or参考"><a href="#扩展阅读or参考" class="headerlink" title="扩展阅读or参考"></a>扩展阅读or参考</h3><p><a href="https://netsecurity.51cto.com/art/202005/617043.htm" target="_blank" rel="noopener">一文读懂HTTPS以及SSL单向验证和双向验证</a></p>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础——笔记</title>
      <link href="/2020/05/19/Linux/"/>
      <url>/2020/05/19/Linux/</url>
      
        <content type="html"><![CDATA[<p>部分Linux基础知识+详细记录部分指令</p><p><a href="https://www.kancloud.cn/wizardforcel/linux-c-book/134922" target="_blank" rel="noopener">Linux c 一站式学习</a></p><a id="more"></a><p><img src="https://img.vim-cn.com/4f/997ad5a19156a30ad1c9c0cecdb8f6f1e65a6e.png" alt=""></p><p>Shell是一个命令行工具。Shell（也称为终端或壳）充当的 是人与内核（硬件）之间的翻译官，用户把一些命令“告诉”终端，它就会调用相应的程序服务去完成某些工作。现在许多主流Linux系统默认使用的终端是Bash（Bourne-Again SHell）解释器。<br><img src="https://img.vim-cn.com/37/8d7196d9a03975e518d1347c3aed2cbcd9ef4e.png" alt=""></p><p><img src="https://img.vim-cn.com/d8/1adfe8ac8a38361bd55673d693dfdd1430b0ff.png" alt=""></p><h3 id="常用系统工作命令"><a href="#常用系统工作命令" class="headerlink" title="常用系统工作命令"></a>常用系统工作命令</h3><ol><li>echo<br>含义：用于在终端输出字符串或变量提取后的值.</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo hello</span><br><span class="line">hello</span><br><span class="line"></span><br><span class="line">echo $SHELL</span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure><ol start="2"><li>date<br>date命令用于显示及设置系统的时间或日期,在强大的date命令中输入以“+”号开头的参数，即可按照指定格式来输出系统的时间或日期</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> date</span></span><br><span class="line"> Mon Aug 24 16:11:23 CST 2017 </span><br><span class="line"><span class="meta">#</span><span class="bash"> date <span class="string">"+%Y-%m-%d %H:%M:%S"</span> </span></span><br><span class="line">2017-08-24 16:29:12 </span><br><span class="line"><span class="meta">#</span><span class="bash"> date <span class="string">"+%j"</span> </span></span><br><span class="line">244 //显示今天是当年当中的第几天</span><br></pre></td></tr></table></figure><ol start="3"><li><p>reboot<br>reboot命令用于重启系统</p></li><li><p>poweroff<br>poweroﬀ命令用于关闭系统</p></li><li><p>wget命令<br>wget命令用于在终端中下载网络文件，格式为“wget [参数] 下载地址”。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> wget -r -p http://www.linuxprobe.com --2017-08-24 19:31:41-- http://www.linuxprobe.com/ Resolving www.linuxprobe.com... 106.185.25.197 Connecting to www.linuxprobe.com|106.185.25.197|:80... connected. HTTP request sent, awaiting response... 200 OK Length: unspecified [text/html] Saving to: <span class="string">'www.linuxprobe.com/index.html'</span></span></span><br></pre></td></tr></table></figure></li><li><p>ps<br>ps命令用于查看系统中的进程状态，格式为“ps [参数]”。</p></li><li><p>top命令<br>top命令用于动态地监视进程活动与系统负载等信息，其格式为top。</p></li><li><p>pidof命令<br>pidof命令用于查询某个指定服务进程的PID值，格式为“pidof [参数] [服务名称]”。<br>例如，可以使用如下命令来查询本机上sshd服务程序的PID：</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pidof sshd </span></span><br><span class="line">2156</span><br></pre></td></tr></table></figure><ol start="9"><li><p>kill命令<br>kill命令用于终止某个指定PID的服务进程，格式为“kill [参数] [进程 PID]”。 </p></li><li><p>killall命令<br>killall命令用于终止某个指定名称的服务所对应的全部进程，格式 为：“killall [参数] [进程名称]”。</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pidof httpd </span></span><br><span class="line">13581 13580 13579 13578 13577 13576 </span><br><span class="line"><span class="meta">#</span><span class="bash"> killall httpd </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> pidof httpd </span></span><br><span class="line"><span class="meta">#</span></span><br></pre></td></tr></table></figure><p>tip:在系统终端中执行一个命令后想立即停止:Ctrl + C,如果有些命令在执行时不断地在屏幕 上输出信息，影响到后续命令的输入，则可以在执行命令时在末尾添加上一个&amp;符号，这样命令将进入 系统后台来执行。</p><h3 id="系统状态监检测命令"><a href="#系统状态监检测命令" class="headerlink" title="系统状态监检测命令"></a>系统状态监检测命令</h3><p>……部分略……</p><ol><li><p>ifconfig<br>ifconﬁg命令用于获取网卡配置与网络状态等信息，格式为“ifconﬁg [网络设备] [参数]”。</p></li><li><p>history命令<br>history命令用于显示历史执行过的命令，格式为“history [-c]”。 能显示最近1000条命令记录。使用-c参数则会清空所有的命令历史记录。</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">history</span> -c</span></span><br></pre></td></tr></table></figure><h3 id="工作目录切换命令"><a href="#工作目录切换命令" class="headerlink" title="工作目录切换命令"></a>工作目录切换命令</h3><ol><li>pwd命令<br>pwd命令用于显示用户当前所处的工作目录，格式为“pwd [选项]”。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">pwd</span> </span></span><br><span class="line">/etc</span><br></pre></td></tr></table></figure><ol start="2"><li><p><strong>cd命令</strong><br>cd命令用于切换工作路径，格式为“cd [目录名称]”。<br>“cd -”：命令返回到上一次所处的目录，<br>“cd ..”：命令进入上级目录，<br>“cd ~”：命令切换到当前用户的家目录，<br>“cd ~username”：切换到其他用户的家目录。</p></li><li><p>ls命令<br>ls命令用于显示目录中的文件信息，格式为“ls [选项] [文件] ”。<br>使用ls命 令的“-a”参数看到全部文件（包括隐藏文件），使用“-l”参数可以查看文 件的属性、大小等详细信息。将这两个参数整合之后，再执行ls命令即可 查看当前目录中的所有文件并输出这些文件的属性信息</p></li></ol><p>tips:</p><ul><li>隐藏文档一般以 “.” 开头；</li><li>“.”表示当前路径；</li><li>“..”表示上一级路径</li><li>使用”ls -la”显示的目录：第一列表示文档类型，”d”表示文件夹，”-“表示文件。例如：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ls -la</span></span><br><span class="line">total 2</span><br><span class="line">dr-xr-x---, #省略后面部分</span><br><span class="line">-rw-------, #省略后面部分</span><br></pre></td></tr></table></figure></li></ul><h3 id="文件文本编辑命令"><a href="#文件文本编辑命令" class="headerlink" title="文件文本编辑命令"></a>文件文本编辑命令</h3><ol><li>cat命令<br>cat命令用于查看纯文本文件（内容较少的），格式为“cat [选项] [文件]”。加一个-n参数显示行号</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat -n [文件]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cat -n initial-setup-ks.cfg</span></span><br></pre></td></tr></table></figure><ol start="2"><li>more命令<br>more命令用于查看纯文本文件（内容较多的），格式为“more [选项] [文件]”。 </li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> more initial-setup-ks.cfg</span></span><br></pre></td></tr></table></figure><ol start="3"><li>head命令<br>head命令用于查看纯文本文档的前N行，格式为“head [选项] [文件]”。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> head -n 20 initial-setup-ks.cfg</span></span><br></pre></td></tr></table></figure><ol start="4"><li>tail命令<br>tail命令用于查看纯文本文档的后N行或持续刷新内容，格式为“tail [选项] [文件]”。<br>tail命令的操作方法与head命令非常相 似，只需要执行“tail -n 20 文件名”命令就可以达到这样的效果。tail命令 最强悍的功能是可以持续刷新一个文件的内容，当想要实时查看最新日志 文件时，这特别有用，此时的命令格式为“tail -f 文件名”</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> tail -f /var/<span class="built_in">log</span>/messages</span></span><br></pre></td></tr></table></figure><ol start="5"><li>tr命令<br>tr命令用于替换文本文件中的字符，格式为“tr [原始字符] [目标字符]”。<br>例如，把某个文本内容中的英文全部替 换为大写：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat anaconda-ks.cfg | tr [a-z] [A-Z]</span></span><br></pre></td></tr></table></figure><ol start="6"><li>wc命令<br>wc命令用于统计指定文本的行数、字数、字节数，格式为“wc [参数] 文本”。</li></ol><p>-l 只显示行数<br>-w 只显示单词数<br>-c 只显示字节数</p><ol start="7"><li><p>stat命令<br>stat命令用于查看文件的具体存储信息和时间等信息，格式为“stat 文件名称”。 </p></li><li><p>cut命令<br>cut命令用于按“列”提取文本字符，格式为“cut [参数] 文本”。 </p></li><li><p>diﬀ命令<br>diﬀ命令用于比较多个文本文件的差异，格式为“diﬀ [参数] 文件”。<br>使用–brief参数来确认两个文件是否不同，<br>使用-c参数来详细比较出多个文件的差异之处</p></li></ol><h3 id="文件目录管理命令"><a href="#文件目录管理命令" class="headerlink" title="文件目录管理命令"></a>文件目录管理命令</h3><ol><li><p>touch命令<br>touch命令用于创建空白文件或设置文件的时间，格式为“touch [选项] [文件]”。</p></li><li><p>mkdir命令<br>mkdir命令用于创建空白的目录，格式为“mkdir [选项] 目录”。<br>在Linux系统中，文件夹是最常见的文件类型之一。除了能创建单个空白目录外，mkdir命令还可以结合-p参数来递归创建出具有嵌套叠层关系的文件目录。</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# mkdir linuxprobe </span><br><span class="line">[root@linuxprobe ~]# cd linuxprobe </span><br><span class="line">[root@linuxprobe linuxprobe]# mkdir -p a/b/c/d/e </span><br><span class="line">[root@linuxprobe linuxprobe]# cd a </span><br><span class="line">[root@linuxprobe a]# cd b </span><br><span class="line">[root@linuxprobe b]#</span><br></pre></td></tr></table></figure><ol start="3"><li>cp命令<br>cp命令用于复制文件或目录，格式为“cp [选项] 源文件 目标文件”。<br>在Linux系统中，复制操作具体分 为3种情况：</li></ol><ul><li>如果目标文件是目录，则会把源文件复制到该目录中； </li><li>如果目标文件也是普通文件，则会询问是否要覆盖它； </li><li>如果目标文件不存在，则执行正常的复制操作。 </li></ul><p>4．mv命令<br>mv命令用于剪切文件或将文件重命名，格式为“mv [选项] 源文件 [目标路径|目标文件名]”。</p><p>剪切操作不同于复制操作，因为它会默认把源文件删除掉，只保留剪 切后的文件。如果在同一个目录中对一个文件进行剪切操作，其实也就是 对其进行重命名：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mv x.log linux.log </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ls </span></span><br><span class="line">install.log linux.log</span><br></pre></td></tr></table></figure><ol start="5"><li>rm命令<br>rm命令用于删除文件或目录，格式为“rm [选项] 文件”。<br>在Linux系统中删除文件时，系统会默认向您询问是否要执行删除操作，如果不想总是看到这种反复的确认信息，可在rm命令后跟上-f参数来 强制删除。另外，想要删除一个目录，需要在rm命令后面一个-r参数才可以，否则删除不掉。我们来尝试删除前面创建的install.log和linux.log文件：</li></ol><p>[root@linuxprobe ~]# rm install.log<br>rm: remove regular empty file ‘install.log’? y<br>[root@linuxprobe ~]# rm -f linux.log<br>[root@linuxprobe ~]# ls<br>[root@linuxprobe ~]# </p><ol start="6"><li><p>dd命令 dd命令用于按照指定大小和个数的数据块来复制文件或转换文件，格 式为“dd [参数]”。</p></li><li><p>ﬁle命令<br>ﬁle命令用于查看文件的类型，格式为“ﬁle 文件名”。 </p><p>在Linux系统中，由于文本、目录、设备等所有这些一切都统称为文件，而我们又不能单凭后缀就知道具体的文件类型，这时就需要使用ﬁle命 令来查看文件类型了。</p></li></ol><p>[root@linuxprobe ~]# file anaconda-ks.cfg  anaconda-ks.cfg: ASCII text [root@linuxprobe ~]# file /dev/sda /dev/sda: block special </p><h3 id="打包压缩与搜索命令"><a href="#打包压缩与搜索命令" class="headerlink" title="打包压缩与搜索命令"></a>打包压缩与搜索命令</h3><ol><li>tar命令<br>tar命令用于对文件进行打包压缩或解压，格式为“tar [选项] [文件]”。-c 创建压缩文件</li></ol><p>-x 解开压缩文件<br>-t 查看压缩包内有哪些文件<br>-z 用Gzip压缩或解压<br>-j 用bzip2压缩或解压<br>-v 显示压缩或解压的过程<br>-f 目标文件名<br>-p 保留原始的权限与属性<br>-P 使用绝对路径来压缩<br>-C 指定解压到的目录</p><h3 id="Vim编辑器"><a href="#Vim编辑器" class="headerlink" title="Vim编辑器"></a>Vim编辑器</h3><p><img src="https://cdn.jsdelivr.net/gh/MrGo123/asset@master/sourceinpost/Linux/VimKeyBoard.png" alt="Vim"></p><p>sudo +操作  ：使用root权限执行操作</p><p>Linux运行有7个级别0-7级。主要3——登录后进入控制台命令行模式；5——登录后进入图形模式；</p><p>VM下切换图形模式与文字模式：图形下alt+shift+Ctrl+F1~F6切换至命令行模式；</p><p>man——查看命令使用；<br>查看ls的使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man ls</span><br></pre></td></tr></table></figure><p>vi撤回操作：命令行下 u 和 ctrl+r</p><h3 id="Linux查询命令帮助"><a href="#Linux查询命令帮助" class="headerlink" title="Linux查询命令帮助"></a>Linux查询命令帮助</h3><blockquote><p>命令是记不完的，但是需要的时候咋办？？？用查询命令查看</p></blockquote><p>三个命令：man、info、whatis.</p><p>使用 man\info\whatis 命令</p><h4 id="man"><a href="#man" class="headerlink" title="man"></a>man</h4><p>man 用来查询命令的帮助文档</p><p>命令的帮助文件有9个章节：</p><ol><li>用户命令 </li><li>系统调用 </li><li>C库调用</li><li>设备文件及特殊文件 </li><li>配置文件格式 </li><li>游戏</li><li>杂项 </li><li>管理类的命令</li><li>Linux 内核API</li></ol><p>man使用</p><ol><li>man 命令</li><li>man 章节号 命令</li></ol><h4 id="whatis"><a href="#whatis" class="headerlink" title="whatis"></a>whatis</h4><p>whatis 显示命令的简短描述</p><p>whatis 命令</p><h4 id="info"><a href="#info" class="headerlink" title="info"></a>info</h4><h2 id="Linux软件包管理"><a href="#Linux软件包管理" class="headerlink" title="Linux软件包管理"></a>Linux软件包管理</h2><p>软件包分为源码包和二进制包（rpm包、系统默认包）</p><p><strong>源码包</strong>：需经过编译转换为机器语言后系统才能识别和运行。<br><strong>优点</strong>：1. 开源；2. 自由选择功能；3. 软件是编译安装的，更适合自己的系统，稳定性和效率更高；4. 卸载方便：直接删除源文件即删除干净，而windows不行。<br><strong>缺点</strong>：1. 安装步骤多，容易出错；2. 编译时间长；3. 安装过程报错难以解决。</p><p><strong>二进制包</strong>：经过了编译的机器语言包，系统能够直接识别和运行——不能看源码、打开是乱码<br><strong>优点</strong>：1. 安装包管理简单；2. 安装迅速<br><strong>缺点</strong>：1. 不可以看源代码；2. 功能选择不自由；3. 依赖性（装某个应用前提需要另一个应用）</p><h3 id="RPM包"><a href="#RPM包" class="headerlink" title="RPM包"></a>RPM包</h3><h4 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h4><p><code>apt</code>，全称<code>Advanced Packaging Tool</code>，Linux下的一款安装包管理工具，可以在终端方便的进行<strong>安装、卸载和更新</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.安装软件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install 软件包</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.卸载软件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt remove</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3.更新软件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt upgrade</span></span><br></pre></td></tr></table></figure><p><code>sudo</code>权限使得所有用户都可以使用这个软件。</p><h3 id="YUM软件仓库"><a href="#YUM软件仓库" class="headerlink" title="YUM软件仓库"></a>YUM软件仓库</h3><p>Yum软件仓库便是为了进一步降低软<br>件安装难度和复杂度而设计的技术。Yum软件仓库可以根据用户的要求分<br>析出所需软件包及其相关的依赖关系，然后自动从服务器下载软件包并安<br>装到系统。</p><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">yum repolist all</td><td align="center">列出所有仓库</td></tr><tr><td align="center">yum list all</td><td align="center">列出仓库中所有软件包</td></tr><tr><td align="center">yum info</td><td align="center">软件包名称查看软件包信息</td></tr><tr><td align="center">yum install</td><td align="center">软件包名称安装软件包</td></tr><tr><td align="center">yum reinstall</td><td align="center">软件包名称重新安装软件包</td></tr><tr><td align="center">yum update</td><td align="center">软件包名称升级软件包</td></tr><tr><td align="center">yum remove</td><td align="center">软件包移除软件包</td></tr><tr><td align="center">yum clean all</td><td align="center">清除所有仓库缓存</td></tr><tr><td align="center">yum check-update</td><td align="center">检查可更新的软件包</td></tr><tr><td align="center">yum grouplist</td><td align="center">查看系统中已经安装的软件包组</td></tr><tr><td align="center">yum groupinstall</td><td align="center">软件包组安装指定的软件包组</td></tr><tr><td align="center">yum groupremove</td><td align="center">软件包组移除指定的软件包组</td></tr><tr><td align="center">yum groupinfo</td><td align="center">软件包组查询指定的软件包组信息</td></tr></tbody></table><h3 id="Linux文件系统编程"><a href="#Linux文件系统编程" class="headerlink" title="Linux文件系统编程"></a>Linux文件系统编程</h3><p><a href="https://blog.csdn.net/zhuyi2654715/article/details/7605051" target="_blank" rel="noopener">Linux下DIR，dirent,stat等结构体详解</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PC系统的一些概念</title>
      <link href="/2020/04/25/PC%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86/"/>
      <url>/2020/04/25/PC%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>PC知识 + 一些概念</p><a id="more"></a><hr><h2 id="三个程序"><a href="#三个程序" class="headerlink" title="三个程序"></a>三个程序</h2><ul><li><p><strong>Shell</strong> 是带有命令提示符(prompt)的用于输入、输出的界面。准确地说，POSIX 桌面底层也运行着一个 Shell，即使这个 Shell 对用户不可见，因为用户会话就是由这个 Shell 启动的。</p></li><li><p><strong>终端</strong>是在图形界面服务器（例如 X11 或 Wayland）中运行的应用程序，其中加载了一个 Shell。只有在终端窗口启动之后，才算是运行了一个终端。终端可以认为是操作 Shell 的一个入口。</p></li><li><p><strong>控制台</strong>（或称“虚拟控制台”）通常表示在桌面环境以外使用的 Shell，你可以通过 Alt+Ctrl+F2 进入控制台，通常情况下从 F3 到 F7 都是不同的控制台，其中桌面环境有可能是 F1 或者 F7，这在不同的发行版中可能会有所不同。</p></li></ul><h2 id="精准搜索"><a href="#精准搜索" class="headerlink" title="精准搜索"></a>精准搜索</h2><p>①排除关键词(减号+关键词)<br>②精确搜索(给关键词加引号)<br>③指定网站内搜索(site：域名  关键词)<br>④指定文件格式(filetype：文件格式  关键词)<br>⑤指定标题搜索(intitle：关键词)<br>⑥⑦两种指定范围搜索(intext：/allintext：)(inurl：关键词)<br>⑧叠加使用<br>正确提取关键词</p>]]></content>
      
      
      <categories>
          
          <category> ComputerBasic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSBasic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符编码</title>
      <link href="/2020/04/02/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
      <url>/2020/04/02/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>ASCII码 + GB2312 + Unicode</p><a id="more"></a><hr><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>啥？作为developer你还不知道字符编码？那还是要学一下。</p><h3 id="几个常见的编码"><a href="#几个常见的编码" class="headerlink" title="几个常见的编码"></a>几个常见的编码</h3><ol><li>ASCII <a href="https://zh.wikipedia.org/zh-hans/ASCII" target="_blank" rel="noopener">维基百科</a></li></ol><p><strong>来源 || 定义</strong><br>ASCII（ /ˈæski/，American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统。它主要用于显示现代英语，而其扩展版本延伸美国标准信息交换码则可以部分支持其他西欧语言，并等同于国际标准ISO/IEC 646。新名字<code>US-ASCII</code>。</p><p><strong>存储实现</strong><br>使用单字节编码，即每个字符占用<strong>一个字节</strong>(8 bit)的后七位，第一位规定为<strong>0</strong>。如 字母 ‘A’,在ASCII码中十进制是65，二进制是<code>0100 0001</code>。</p><blockquote><p>把最高位也拿来用之后就称为非ASCII编码，ISO-8859-1编码就是如此。</p></blockquote><p><strong>缺点 || 局限</strong><br>ASCII只能显示26个基本的拉丁字符、阿拉伯数字和英式标点符号，共<strong>128</strong>个字符。仅用于显示现代美国英语。</p><blockquote><p>现大多数系统使用支持更多语言的Unicode。</p></blockquote><ol start="2"><li>GB2312 <a href="https://zh.wikipedia.org/wiki/GB_2312" target="_blank" rel="noopener">维基百科</a></li></ol><p><strong>来源 || 定义</strong></p><p>GB/T 2312，GB/T 2312–80 或 GB/T 2312–1980 是中华人民共和国国家标准简体中文字符集，全称《信息交换用汉字编码字符集·基本集》，通常简称GB，又称GB0，由中国国家标准总局发布，1981年5月1日实施。GB/T 2312编码通行于中国大陆；新加坡等地也采用此编码。中国大陆几乎所有的中文系统和国际化的软件都支持GB/T 2312。</p><p>GB/T 2312标准共收录6763个汉字，其中一级汉字3755个，二级汉字3008个；同时收录了包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母在内的682个字符。</p><p><strong>存储实现——分区表示</strong></p><p>双字节编码</p><p>每区含有94个汉字／符号，共计94个区。用所在的区和位来表示字符（实际上就是码位），因此称为区位码（或许叫“区位号”更为恰当）。表示方式也称为区位码。例如“万”字在45区82位，所以“万”字的区位码是：45 82（注意，GB类汉字编码为双字节编码，因此，45相当于高位字节，82相当于低位字节）。</p><ul><li><strong>01~09区（682个）</strong>：特殊符号、数字、英文字符、制表符等，包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母等在内的682个全角字符；</li><li>10~15区：空区，留待扩展；在附录3，第10区推荐作为 GB 1988–80 中的94个图形字符区域（即第3区字符之半形版本）。</li><li><strong>16~55区（3755个）</strong>：常用汉字（也称一级汉字），按拼音排序；</li><li>56~87区（3008个）：非常用汉字（也称二级汉字），按部首/笔画排序；</li><li>88~94区：空区，留待扩展。</li></ul><ol start="3"><li>Unicode <a href="https://zh.wikipedia.org/wiki/Unicode" target="_blank" rel="noopener">维基百科</a></li></ol><p><strong>来源 || 定义</strong></p><p>Unicode是为了解决传统的字符编码方案的局限而产生的。Unicode（中文：万国码、国际码、统一码、单一码）是计算机科学领域里的一项业界标准。它对世界上大部分的文字系统进行了整理、编码，使得电脑可以用更为简单的方式来呈现和处理文字。</p><p>Unicode 至今仍在不断增修，每个新版本都加入更多新的字符。当前最新的版本为2019年5月公布的12.1.0[2]，已经收录超过13万个字符（第十万个字符在2005年获采纳）。Unicode涵盖的数据除了视觉上的字形、编码方法、标准的字符编码外，还包含了字符特性，如大小写字母。</p><p><strong>存储实现——分区表示</strong></p><p>Unicode是指一张表，里面包含了可能出现的所有字符，每个字符对应一个数字，这个数字称为码点(Code Point)，如字符’H’的码点为72（十进制），字符’李’的码点为26446（十进制）。Unicode表包含了1114112个码点，即从000000（十六进制） - 10FFFF（十六进制）。地球上所有字符都可以在Unicode表中找到对应的唯一码点。点击这里，查询字符对应的码点。Unicode将码空间划分为17个平面，从00 - 10（十六进制，最高两位），即从0 - 16（十进制），每个平面有65536个码点（2^16），其中最重要的是第一个Unicode平面(码位从0000 - FFFF)，包含了最常用的字符，该平面被称为基本多语言平面（Basic Multilingual Plane），缩写为BMP，其他平面称为辅助平面(Supplementary Planes)，在基本多文种平面內， 从D800到DFFF之间的码位区段是永久保留不映射到字符的， 因此UTF-16编码巧妙的利用了这保留下来的码位来对辅助平面内的字符进行编码，这点后面进行讲解。Unicode只是一个符号集，只规定的字符所对应的码点，并没有指定如何存储，如何进行存储出现了不同的编码方案，关于Unicode编码方案主要有两条主线：UCS和UTF。UTF主线由Unicode Consortium进行维护管理，UCS主线由ISO/IEC进行维护管理。</p><hr><p>先码一手dalao整理的干货</p><ul><li><a href="https://www.cnblogs.com/leesf456/p/5317574.html" target="_blank" rel="noopener">【字符编码】彻底理解字符编码</a></li></ul><blockquote><p>对 <code>ASCII</code>、<code>ISO-8859-1</code>、<code>GB2312</code>、<code>BIG5</code>、<code>GBK</code>、<code>Unicode</code>、<code>UCS</code>、<code>UCS-2</code>、<code>UCS-4</code>、<code>UTF</code>、<code>UTF-8</code>、<code>UTF-16</code>进行了整理，并对其中的部分进行了区别比较。</p></blockquote><ul><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260469698963456" target="_blank" rel="noopener">廖雪峰java教程——字符编码</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ComputerBasic </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>踩坑大杂烩</title>
      <link href="/2020/02/23/%E8%B8%A9%E5%9D%91%E5%A4%A7%E6%9D%82%E7%83%A9/"/>
      <url>/2020/02/23/%E8%B8%A9%E5%9D%91%E5%A4%A7%E6%9D%82%E7%83%A9/</url>
      
        <content type="html"><![CDATA[<p>记录所遇到的问题+解决方法</p><a id="more"></a><h2 id="坑1————ssh：time-out"><a href="#坑1————ssh：time-out" class="headerlink" title="坑1————ssh：time out"></a>坑1————ssh：time out</h2><p>某日夜，想要在github上clone一repo，照常执行 <code>git clone git@……</code><br>等待片刻：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh: connect to host github.com port 22: Connection timed out</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br></pre></td></tr></table></figure><p>我：😳😳XXX????????<br>继续检查</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line">ssh: connect to host github.com port 22: Connection timed out</span><br></pre></td></tr></table></figure><p>🌚🌚好吧！找度娘！查博客！<br>解决：在.ssh下有另外三个文件的情况下再建立config文件（文件名无后缀）<br>文件内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">User &#39;github上的email&#39;</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~&#x2F;.ssh&#x2F;id_rsa</span><br><span class="line">Port 443</span><br></pre></td></tr></table></figure><p>完了之后，长这样<br><img src="https://img.vim-cn.com/fb/fb55f6895f15e942019d570564f15d869287b9.png" alt=""></p><p>再去执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>后面 <code>yes</code>。solved。🍻🍻</p><h2 id="坑2–安装MySQL"><a href="#坑2–安装MySQL" class="headerlink" title="坑2–安装MySQL"></a>坑2–安装MySQL</h2><blockquote><p>由于第一次安装MySQL，为了稳定起见，特地找了两篇教程对照着安装。结果…………错错错，都是你的……。(zanghua).没事，我也就一共装了五次🌚🌚，总耗时不下4h罢了.(zanghua)Oh, I am growing right?? Keep calm. 其实最后错误都只是一个：密码错误。</p></blockquote><p>下面按安装顺序记录所有的问题：<br>安装到这一步：finish.<br>successfully finished \撒花\撒花。</p><p>生活没有那么容易，每个人……🌗🌗</p><hr><ol><li>启动某client,闪退</li></ol><p>😀😀😀，问题不大，我还能笑。</p><p>闪退……闪退……闪退……</p><p>😅😅😅，问题不大，我网上找找。</p><ul><li>人家说mysql没在运行，不好意思，我的在跑。</li><li>人家说啥啥啥，不好意思，我试了，没用。</li></ul><p>😐😐😐<br>…………</p><ol start="2"><li>修改登录免密码后，启动mysql：本地计算机上的MySQL服务启动后停止。某些服务在未由其他服务或程序使用时将自动停止</li></ol><p>😶😶😶<br>…………<br>（网上教程花里胡哨，不如重装）<br>still……still……still</p><p>😣😣😣😖😖😖😡😡😡</p><ol start="3"><li>access denied for user ‘root’@’localhost’ (using password:YES)</li></ol><p>综合网上解决方案——密码错误………………继续上述第2步……重装。</p><p>(崩溃边缘)</p><p>重装。</p><p><strong>转折来了</strong></p><blockquote><p>既然上述的是密码错误，那我换个密码。</p></blockquote><p>卸载-&gt;干净卸载-&gt;重装-&gt;谨慎重装-&gt;输入初始化的root密码-&gt;……-&gt;finish.</p><p>🌚🌚🌚client 启动。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTER PASSWARD:******</span><br></pre></td></tr></table></figure><p>done!!!! What happened??? what ??</p><p>Thanks god!! Yearh.</p><p><strong>总结：不是PC的错，更不是MySQL的错，也不是教程的错，错就错在我输入的密码中有特殊符号，这是我所不能理解的。</strong></p><p><strong>教训：特殊条件下，谨慎设密码，越简单越好。</strong></p><p>走过，踩过，以后才会少犯错。🌝🌝🌝</p>]]></content>
      
      
      <categories>
          
          <category> Mark </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Github相关</title>
      <link href="/2020/02/21/Github%E7%9B%B8%E5%85%B3/"/>
      <url>/2020/02/21/Github%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p><a href="#Github上动态浏览历史版本">动态浏览历史版本</a> + <a href="#Github上精准搜索">精准搜索</a> + 项目中添加徽标</p><a id="more"></a><hr><h3 id="Github上动态浏览历史版本"><a href="#Github上动态浏览历史版本" class="headerlink" title="Github上动态浏览历史版本"></a>Github上动态浏览历史版本</h3><p>版本控制、版本控制，当我们要浏览历史版本的时候怎么玩才更舒服更香呢？？</p><p>这里就有一顿操作——动态可视化看历史版本。</p><ol><li>通过更改URL</li></ol><p>具体操作：把 URL 中的 <a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a> 替换成 <a href="https://github-history.netlify.com/，URL的其它部分保持不变。回车即跳转至在酷的版本页面，而且版本转换时支持动态效果。" target="_blank" rel="noopener">https://github-history.netlify.com/，URL的其它部分保持不变。回车即跳转至在酷的版本页面，而且版本转换时支持动态效果。</a></p><ol start="2"><li>通过Chrome插件</li></ol><p>上述的操作有Chrome插件：Git History Browser</p><blockquote><p>我还没安排………………</p></blockquote><h3 id="Github上精准搜索"><a href="#Github上精准搜索" class="headerlink" title="Github上精准搜索"></a>Github上精准搜索</h3><p>如果简单搜索 <code>java</code> ,就会得到一大堆有 <code>java</code> 字眼的项目。</p><p>当然或许你可以 <code>Sort</code> 排序一下，emmmm……那必须是个好东西，香<del>~</del>，可以根据不同要求排序：</p><p><img src="https://s2.ax1x.com/2020/02/10/1IknDe.png" alt="1IknDe.png"></p><p>但是那不叫搜索技巧，打扰了<del>~</del></p><p>So,look at this &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p><h4 id="1-name-搜索含关键词为名称的项目"><a href="#1-name-搜索含关键词为名称的项目" class="headerlink" title="1.name:搜索含关键词为名称的项目"></a>1.name:搜索含关键词为名称的项目</h4><ul><li>不加条件</li></ul><p>搜java： </p><blockquote><p>in:name java</p></blockquote><p>搜索结果：<br><img src="https://s2.ax1x.com/2020/02/10/1IAyFA.png" alt="1IAyFA.png"></p><blockquote><p>可见，结果只是项目名称中包含所搜关键词的，即搜索的中心只在名称上。</p></blockquote><ul><li>添加条件的搜索</li></ul><blockquote><p>in:name java stars:&gt;5000 </p></blockquote><blockquote><p>in:name java forks:&gt;2000</p></blockquote><blockquote><p>in:name java stars:&gt;5000 forks:&gt;2000</p></blockquote><blockquote><p>in:name 电商项目 language:java pushed:&gt;YYYY-MM-DD //pushed根据的是最后更新时间</p></blockquote><p>emmmm……图片都一样的捏，都是那几个项目。罢了，重点在文字内容。<br>以此不断细化、减少搜索结果，使得搜索更准确。</p><h4 id="2-其他搜索"><a href="#2-其他搜索" class="headerlink" title="2.其他搜索"></a>2.其他搜索</h4><p>搜索README中含有关键词的项目</p><blockquote><p>in:readme ……</p></blockquote><p>搜索项目描述中含有关键词的项目</p><blockquote><p>in:description ……</p></blockquote><p>tips:添加条件操作如同<code>name</code>，No赘述！！！<br><span style="color:red">Warning:</span> 禁止用中文输入下的符号 Useless！！！</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://mp.weixin.qq.com/s/ltg9S_jLjzwK42BFAnRyKA" target="_blank" rel="noopener">如何在Gihub上面精准搜索开源项目？</a></p><p><a href="https://juejin.im/post/5a32157c6fb9a0450b6667ac" target="_blank" rel="noopener">GitHub 项目徽章的添加和设置</a>————————我还没搞呢。码</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI4NTAyOTA0OA==&mid=2457432869&idx=1&sn=2a916adcff63c7350eb9bafdb1324316&chksm=fc7fb4f2cb083de443609f04d8db18da5f91c51eebddbda3d5c43ed2dc1fc694f5838da53337&mpshare=1&scene=23&srcid=&sharer_sharetime=1590104527832&sharer_shareid=2cc947b5ca5c4f3edc65c12deeab5c55#rd" target="_blank" rel="noopener">Github上动态浏览历史版本参考</a></p>]]></content>
      
      
      <categories>
          
          <category> git/github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yaml</title>
      <link href="/2020/02/08/yaml/"/>
      <url>/2020/02/08/yaml/</url>
      
        <content type="html"><![CDATA[<blockquote><p>YAML简介+基本语法+数据类型+复合结构+纯量+引用</p></blockquote><a id="more"></a><hr><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>YAML：全称”Yet Another Markup Language”（仍是一种标记语言）。yaml是以数据中心的标记语言。YAML配置文件的文件后缀是<code>.yml</code>。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ul><li>大小写敏感</li><li>使用缩进表示层级关系（只允许使用空格，不允许使用tab）</li><li>相同层级左对齐</li><li>‘#’表示注释</li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>数据类型包括：对象、数组、纯量。</p><h4 id="1-对象"><a href="#1-对象" class="headerlink" title="1. 对象"></a>1. 对象</h4><p>对象：键值对的集合，或称映射。</p><p>对象键值对使用冒号结构表示：<code>key: value</code>.<strong>冒号后有一个空格</strong>，例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">key:</span></span><br><span class="line">    <span class="attr">key1:</span> <span class="string">value1</span></span><br><span class="line">    <span class="attr">key2:</span> <span class="string">value2</span></span><br></pre></td></tr></table></figure><p>或者用<strong>流式语法</strong>表示为<code>key:{key1: value1,key2: value2}</code></p><h4 id="2-数组"><a href="#2-数组" class="headerlink" title="2. 数组"></a>2. 数组</h4><p>yaml以<code>-</code>开头的行表示构成一个数组。例如A、B、C三个数组：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">A</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">B</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">C</span></span><br></pre></td></tr></table></figure><p><strong>多维数组</strong><br>即在一个数组元素下还是一个数组的数组。例如如下二维数组：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> </span><br><span class="line"> <span class="bullet">-</span> <span class="string">A</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">B</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">C</span></span><br></pre></td></tr></table></figure><p><strong>复合结构</strong><br>复合结构即为较为复杂的数组，由对象和数组结合。如C语言等中的结构体数组。例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">information:</span></span><br><span class="line">     <span class="bullet">-</span> </span><br><span class="line">        <span class="attr">name:</span> <span class="string">Zhangsan</span></span><br><span class="line">        <span class="attr">age:</span> <span class="number">20</span></span><br><span class="line">        <span class="attr">hight:</span> <span class="number">175</span></span><br><span class="line">     <span class="bullet">-</span> </span><br><span class="line">        <span class="attr">name:</span> <span class="string">Lisi</span></span><br><span class="line">        <span class="attr">age:</span> <span class="number">21</span></span><br><span class="line">        <span class="attr">hight:</span> <span class="number">170</span></span><br></pre></td></tr></table></figure><p>即<code>information</code>数组有两个元素，每个元素由name、age、hight三个元素组成。亦可以按<code>information: [{name: Zhangsan,age: 20,hight: 175},{name: Lisi,age: 21,hight:170}]</code>表示</p><h4 id="3-纯量"><a href="#3-纯量" class="headerlink" title="3. 纯量"></a>3. 纯量</h4><p>纯量是最基本的、不可再分的值。包括：</p><ul><li>字符串</li></ul><blockquote><p>字符串默认不用加上单引号或双引号：<br>双引号””：不会转义字符里的特殊字符，长什么样就输出什么样。<br>单引号’’：会转义字符串里的特殊字符。</p></blockquote><blockquote><p>转义：转换成字符所包含的含义。</p></blockquote><ul><li>布尔值</li><li>整数</li><li>浮点数</li><li>Null</li><li>时间</li><li>日期</li></ul><p>eg:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">String:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">你好</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"hello \n world"</span> <span class="comment">#原样输出</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">'Hello world'</span>  <span class="comment">#可以使用双引号或者单引号包裹特殊字符</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">newline</span></span><br><span class="line">    <span class="string">newline2</span>    <span class="comment">#字符串可以拆成多行，每一行会被转化成一个空格</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Boolean:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="literal">true</span> <span class="comment">#无所谓大小写</span></span><br><span class="line">  <span class="bullet">-</span> <span class="literal">False</span> </span><br><span class="line"></span><br><span class="line"><span class="attr">int:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">123</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">0b1010_0111_0100_1010_1110</span>    <span class="comment">#二进制表示</span></span><br><span class="line"></span><br><span class="line"><span class="attr">float:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">3.14</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">6.8523015e+5</span>  <span class="comment">#可以使用科学计数法</span></span><br><span class="line"></span><br><span class="line"><span class="attr">null:</span></span><br><span class="line">  <span class="attr">nodeName:</span> <span class="string">'node'</span></span><br><span class="line">  <span class="attr">parent:</span> <span class="string">~</span>  <span class="comment">#使用~表示null</span></span><br><span class="line"></span><br><span class="line"><span class="attr">datetime:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="number">2018</span><span class="number">-02</span><span class="string">-17T15:02:31+08:00</span>    <span class="comment">#时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区</span></span><br><span class="line"></span><br><span class="line"><span class="attr">date:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">2018</span><span class="number">-02</span><span class="number">-17</span>    <span class="comment">#日期必须使用ISO 8601格式，即yyyy-MM-dd</span></span><br></pre></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>通过联合使用下面三个符号实现引用<br> <code>&amp;</code> ：建立锚点<br> <code>*</code>：引用锚点。<br> &lt;&lt;：表示合并到当前数据<br> 例如<br> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="attr">defaults:</span> <span class="meta">&amp;defaults</span></span><br><span class="line">  <span class="attr">adapter:</span>  <span class="string">postgres</span></span><br><span class="line">  <span class="attr">host:</span>     <span class="string">localhost</span></span><br><span class="line"></span><br><span class="line"><span class="attr">development:</span></span><br><span class="line">  <span class="attr">database:</span> <span class="string">myapp_development</span></span><br><span class="line">  <span class="string">&lt;&lt;:</span> <span class="meta">*defaults</span></span><br><span class="line"></span><br><span class="line"><span class="attr">test:</span></span><br><span class="line">  <span class="attr">database:</span> <span class="string">myapp_test</span></span><br><span class="line">  <span class="string">&lt;&lt;:</span> <span class="meta">*defaults</span></span><br></pre></td></tr></table></figure></p><p>相当于:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">defaults:</span></span><br><span class="line">  <span class="attr">adapter:</span>  <span class="string">postgres</span></span><br><span class="line">  <span class="attr">host:</span>     <span class="string">localhost</span></span><br><span class="line"></span><br><span class="line"><span class="attr">development:</span></span><br><span class="line">  <span class="attr">database:</span> <span class="string">myapp_development</span></span><br><span class="line">  <span class="attr">adapter:</span>  <span class="string">postgres</span></span><br><span class="line">  <span class="attr">host:</span>     <span class="string">localhost</span></span><br><span class="line"></span><br><span class="line"><span class="attr">test:</span></span><br><span class="line">  <span class="attr">database:</span> <span class="string">myapp_test</span></span><br><span class="line">  <span class="attr">adapter:</span>  <span class="string">postgres</span></span><br><span class="line">  <span class="attr">host:</span>     <span class="string">localhost</span></span><br></pre></td></tr></table></figure><h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><ol><li><code>---</code>:表示一个文档的开始，可以用在同一个文件中。亦可用来分割不同内容。如Springboot中的profile定义：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">    <span class="attr">address:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">profiles:</span> <span class="string">development</span></span><br><span class="line">    <span class="attr">server:</span></span><br><span class="line">        <span class="attr">address:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">profiles:</span> <span class="string">production</span></span><br><span class="line">    <span class="attr">server:</span></span><br><span class="line">        <span class="attr">address:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.120</span></span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://www.runoob.com/w3cnote/yaml-intro.html" target="_blank" rel="noopener">菜鸟教程</a></li><li><a href="https://www.ruanyifeng.com/blog/2016/07/yaml.html" target="_blank" rel="noopener">阮一峰yaml教程</a></li><li><a href="https://yaml.org/spec/1.2/spec.pdf" target="_blank" rel="noopener">YAML1.2规范.pdf</a></li><li><a href="https://www.jianshu.com/p/97222440cd08" target="_blank" rel="noopener">简书-博文</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> YAML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> yaml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简述博客搭建</title>
      <link href="/2020/01/30/%E7%AE%80%E8%BF%B0%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2020/01/30/%E7%AE%80%E8%BF%B0%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>记录博客搭建的一些信息or教程</p><a id="more"></a><p>前叙：本博是在Shan San的引路下自己不断摸索整的，主要是有TRHX大佬写的究极详细的小白教程，真的是小白，无脑跟着操作就OK，可先不理解，把东西先做出来，这里安利一下大佬的CSDN专栏</p><ol><li><a href="https://itrhx.blog.csdn.net/article/details/82121420" target="_blank" rel="noopener">使用 Github Pages 和 Hexo 搭建自己的独立博客【超级详细的小白教程】</a></li><li><a href="https://itrhx.blog.csdn.net/article/details/85420403" target="_blank" rel="noopener">Hexo 博客优化之博客美化系列（持续更新）</a></li><li><a href="https://itrhx.blog.csdn.net/article/details/85010191" target="_blank" rel="noopener">Hexo 博客优化之实用功能添加系列（持续更新）</a></li></ol><p>有了以上大佬的三个专栏，beautiful blog就有了。当然Hexo官方文档是必不可少的。</p><hr><p>下面是我自己建博的简要记录：<br>前备知识：HTML + yaml + Git/Github + CSS + JS</p><blockquote><p>tips：没有就见啥学啥吧。just like me！didiwanyier。</p></blockquote><p>基础配置要求</p><ol><li>Node.js  官网下载</li><li>Git  官网下载</li><li>Hexo</li></ol><h3 id="本地创建"><a href="#本地创建" class="headerlink" title="本地创建"></a>本地创建</h3><blockquote><p>自己新建一个文件夹，用来放博客文件，右键Git Bash here，分别输入如下命令安装</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-cli -g  </span><br><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后再建个名为Hexo的文件夹，右键Git Bash Here输入<br><code>$ hexo init</code><br>进行初始化，接着部署Hexo，执行命令：<br><code>$ hexo generate</code><br>然后执行命令<br><code>$ hexo server</code><br>运行本地服务器，打开<br><code>http://localhost:4000/</code><br>打开博客。至此本地博客建好了。</p><h3 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h3><p>配置SSH+Git登录个人账户+clone新建的仓库至Hexo文件夹</p><p>更换到Hexo官网选一款中意的Hexo主题，阅读Hexo说明书，修改优化主题配置。添加评论系统，我使用的是Valine+它的一个高级扩展。（这里也会有Valine的配置说明要读）到这博客就差不多建好了。更细更个性化可以自己修改主题源代码。</p><hr><hr><h3 id="绑定域名-实现https"><a href="#绑定域名-实现https" class="headerlink" title="绑定域名+实现https"></a>绑定域名+实现https</h3><h4 id="1-运营商买域名"><a href="#1-运营商买域名" class="headerlink" title="1.运营商买域名"></a>1.运营商买域名</h4><p><img src="https://img.vim-cn.com/cb/053e0bc35e50bee029aec5506e9d0b868ecc9f.png" alt=""></p><h4 id="2-域名解析"><a href="#2-域名解析" class="headerlink" title="2.域名解析"></a>2.域名解析</h4><p>点上图中的<strong>解析</strong>，然后<strong>添加记录</strong>，记录的内容按矩形方框所示，然后<strong>确定</strong>。<br><img src="https://img.vim-cn.com/34/bfd55fe683b6b51c3f4ba2146a4b2658cc7699.png" alt=""><br>tips: github的域名即<code>xxx.github.io</code>填的时候<code>io</code>后面还有个 <code>.</code>。</p><h4 id="3-建CNAME文件"><a href="#3-建CNAME文件" class="headerlink" title="3.建CNAME文件"></a>3.建CNAME文件</h4><p>到github博客的source文件夹内创建名为CANME的文件，里面的内容是所购买的域名,不包含前缀。<br><img src="https://img.vim-cn.com/25/f45fb8259d01d03efb86c04a619b1b5ef5e9cb.png" alt=""></p><h4 id="4-部署发布"><a href="#4-部署发布" class="headerlink" title="4.部署发布"></a>4.部署发布</h4><p>整完上面博客<code>$ hexo g -d</code>一下。</p><h4 id="5-到github上save域名"><a href="#5-到github上save域名" class="headerlink" title="5.到github上save域名"></a>5.到github上save域名</h4><p>打开github-&gt;博客仓-&gt;Setting-&gt;github page,看图：<br><img src="https://img.vim-cn.com/3d/def3314a3dd1e9e0c0aa1f3da08f31e803ff6c.png" alt=""></p><h4 id="6-收获http"><a href="#6-收获http" class="headerlink" title="6.收获http"></a>6.收获http</h4><p>等一会，几分钟吧！（人家教程都这样说）oh！<code>http://zy68.top</code>，真香！！https不更香？？下面就是https踩坑路。</p><hr><h4 id="7-整SSL证书"><a href="#7-整SSL证书" class="headerlink" title="7.整SSL证书"></a>7.整SSL证书</h4><p>回到<strong>域名控制台</strong>，点击域名列表中购买了的<strong>域名</strong>，出现该域名的<strong>基本信息</strong>，点击下面的<strong>开启SSL证书</strong>，然后出现两个一千多的SSL证书！（打扰了！回去耕田）点击<strong>返回证书列表</strong>，<strong>购买证书</strong><br><img src="https://img.vim-cn.com/d4/e0f3de78fe5d30d6e089b9e0858cd2fec7abbd.png" alt=""><br>oh! free.真香！！！然后那个啥没问题就等签发吧，十分钟不到。<br><img src="https://img.vim-cn.com/d6/5ea5302d51b6ad254070384f6a28656cd3c4b7.png" alt=""></p><h4 id="8-github上打钩"><a href="#8-github上打钩" class="headerlink" title="8.github上打钩"></a>8.github上打钩</h4><p>拿到证书之后到github老位置打√。<br><img src="https://img.vim-cn.com/b2/f7b858b81698ddcf32771bd3da960b8a4353d6.png" alt=""><br>oh!https,真香！！结束</p><p>tips：这里记个坑，如果上述第二步域名解析用了网上其他教程的：还有另外一个解析记录，其中的记录类型为A类型的话，github上的勾勾是不容易√上的，需要做另外的DNS操作。最简单的做法是：把A的解析记录删了，然后去打钩，over。</p><p>奉上两篇Shan San整来的official docs：</p><ul><li><p><a href="https://help.github.com/en/github/working-with-github-pages/managing-a-custom-domain-for-your-github-pages-site?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">Managing a custom domain for your GitHub Pages site</a></p></li><li><p><a href="https://github.blog/2018-05-01-github-pages-custom-domains-https/" target="_blank" rel="noopener">Custom domains on GitHub Pages gain support for HTTPS</a></p></li></ul><h3 id="其他推荐"><a href="#其他推荐" class="headerlink" title="其他推荐"></a>其他推荐</h3><blockquote><p>从零基于github pages和使用jekyll搭建自己的网站 <a href="https://aleksandrhovhannisyan.github.io/blog/dev/creating-a-personal-website-with-jekyll-and-github-pages-a-comprehensive-guide/" target="_blank" rel="noopener">Creating a Personal Website with Jekyll and GitHub Pages: A Comprehensive Guide</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>didi算法相关知识</title>
      <link href="/2020/01/28/Algorithm/"/>
      <url>/2020/01/28/Algorithm/</url>
      
        <content type="html"><![CDATA[<p>数学函数的使用+一些小知识</p><a id="more"></a><h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><p>要使用数学函数首先引入头文件 <code>&lt;math.h&gt;</code> </p><ol><li>三角函数</li></ol><ul><li><p>自变量以弧度制，即 <code>度数/180*π</code>，π≈3.1415926.</p></li><li><p>自变量和返回值均为<code>double</code>型</p></li></ul><p>常用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cos</span><span class="params">(<span class="keyword">double</span> x)</span></span>; <span class="comment">//返回x的余弦值</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sin</span><span class="params">(<span class="keyword">double</span> x)</span></span>; <span class="comment">//返回x的正弦值</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">tan</span><span class="params">(<span class="keyword">double</span> x)</span></span>; <span class="comment">//返回x的正切值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> x)</span></span>; <span class="comment">//返回整型数值得绝对值</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">fabs</span><span class="params">(<span class="keyword">double</span> x)</span></span>; <span class="comment">//返回双精度double型数值的绝对值</span></span><br><span class="line"><span class="built_in">pow</span>(<span class="number">3.14</span>,<span class="number">2</span>);<span class="comment">//3.14的平方</span></span><br></pre></td></tr></table></figure><p>int都是32位整数，范围是-2147483648～2147483647。</p><p>计时函数clock（）的使用。该函数返回<strong>程序启动</strong>到目前为止运行的时间，在程序结束之前调用此函数，便可获得整个程序的运行时间。这个时间除以常数CLOCKS_PER_SEC之后得到的值以“秒”为单位。<code>#include&lt;time.h&gt;</code></p><p>鲁棒性：在算法竞赛中，偶尔会出现输入输出错误的情况。如果程序鲁棒性强，有 时能在数据有瑕疵的情况下仍然给出正确的结果。程序的鲁棒性在工程中也非常重要。</p><p>scanf函数有返回值？对，它返回的是成功输入的变量个数，当输入结束时，scanf函数无法再次读取x，将返回0。判断scanf函数的返回值可以增强程序的鲁棒性。</p><p>结束输入程序：在Windows下，输入完毕后先按Enter键，再按Ctrl＋Z键，最后再按Enter键，即可结束输入。在Linux下，输入完毕后按Ctrl＋D键即可结束输入。</p><p>当嵌套的两个代码块中有同名变量时，内层的变量会屏蔽外层变量</p><p>long long 型 输入输出用 <code>%lld</code>。</p><p><strong><code>.c</code>文件编译后的产生的可执行文件都保存了啥？</strong></p><p>编译后的文件与操作系统有关，但都有<strong>段</strong>的概念，段是指二进制文件内的区域，所有某种特定类型信息被保存在里面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;<span class="built_in">size</span> a.exe</span><br><span class="line"><span class="built_in">text</span> data bss dec hex filename</span><br><span class="line"><span class="number">2756</span> <span class="number">740</span> <span class="number">224</span> <span class="number">3720</span> e88 a.exe</span><br></pre></td></tr></table></figure><p>此结果表示 <code>a.exe</code>由<code>正文段</code>、<code>数据段</code>和 <code>bss</code> 段组成，总大小是3720，用十六进制表示为<br>e88，文件名为 <code>a.exe</code>。其中：</p><ul><li>正文段（Text Segment）：用于存储指令；</li><li>数据段（Data Segment）：用于存储已初始化的全局变量；</li><li>BSS段（BSS Segment）：用于存储未赋值的全局变量所需的空间。</li></ul><p>对于程序运行中用到的堆栈会在运行时创建，调用栈所在的段称为<code>堆栈段</code>（Stack Segment）。与其他段一样，堆栈段有自己的大小，且不能被越界访问，否则出现段错误(Segmentation Fault)。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ol><li><a href="https://blog.csdn.net/dy_Learning/article/details/7740801" target="_blank" rel="noopener">C语言常用库函数</a></li><li>[经典算法竞赛入门]</li></ol>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaSE--8.集合/容器</title>
      <link href="/2020/01/20/javaSE-8-%E9%9B%86%E5%90%88-%E5%AE%B9%E5%99%A8/"/>
      <url>/2020/01/20/javaSE-8-%E9%9B%86%E5%90%88-%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>集合框架</p><a id="more"></a><p>java集合框架主要包括两种类型的容器：</p><ol><li>集合(Collection)：存储一个元素的集合；</li><li>图：存储键/值对映射。</li></ol><p><img src="https://s2.ax1x.com/2020/01/20/1icFzR.md.png" alt="1icFzR.md.png"></p><p><span style="color:lightgray">图片来源于菜鸟教程</span></p><p>未完整…………</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ol><li><a href="https://www.runoob.com/java/java-collections.html" target="_blank" rel="noopener">菜鸟教程</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> javaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaSE--7.泛型</title>
      <link href="/2020/01/20/javaSE-7-%E6%B3%9B%E5%9E%8B/"/>
      <url>/2020/01/20/javaSE-7-%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>简单认识泛型</p><a id="more"></a><p>泛型程序设计意味着编写的代码可以被多中种不同类型的对象所重用。</p><blockquote><p>就是写一个东西，支持好多对象去使用。可简称广泛的类型。</p></blockquote><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>定义：一个泛型类就是具有一个或多个类型变量的类。</p><p>例如下面代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>,<span class="title">U</span>&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> T first;</span><br><span class="line">  <span class="keyword">private</span> U second;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span></span>&#123;</span><br><span class="line">    first=<span class="keyword">null</span>;</span><br><span class="line">    second= <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, U second)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.first=first;</span><br><span class="line">    <span class="keyword">this</span>.second=second;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> first;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> U <span class="title">getSecond</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> second;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Pair类引入了两个类型变量T和U，用尖括号&lt;&gt;括起来，并放在类名后面。泛型类可以有一个或多个类型变量。类型变量名常用短大写形式。</p></blockquote><p>实例化泛型类型：用具体的类型替换类型变量。如上述类：<code>Pair(String,int)</code> ,则所有的T转换为<code>String</code>类型、所有的U转换为<code>int</code>类型。</p><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getMiddle</span><span class="params">(T …a)</span></span>&#123;<span class="comment">//注意类型变量所在的位置</span></span><br><span class="line">    <span class="keyword">return</span> a[a.length/<span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型方法可以定义在泛型类中也可以定义在普通类中。调用时在方法名的尖括号内放入具体的类型。也可以不放，编译器自己能够推断出所调用的方法。eg: <code>String middle = ArrayAlg.&lt;String&gt;getMiddle(&quot;~&quot;,……,&quot;~&quot;)</code></p><h3 id="类型变量的限定"><a href="#类型变量的限定" class="headerlink" title="类型变量的限定"></a>类型变量的限定</h3><p>…………</p><hr><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ol><li><a href="">java核心技术 卷1</a></li><li><a href="">菜鸟教程</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> javaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven</title>
      <link href="/2020/01/20/Maven/"/>
      <url>/2020/01/20/Maven/</url>
      
        <content type="html"><![CDATA[<p>简介+下载、配置+核心概念+参考文档</p><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  为进一步<del>学习</del>Spring等框架以及java深入，得入maven这个坑。</p><hr><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="一、简要认识Maven"><a href="#一、简要认识Maven" class="headerlink" title="一、简要认识Maven"></a>一、简要认识Maven</h4><p>简介：Maven是一个java的项目管理工具，可以对java项目进行构建、依管理。</p><p>使用目的：方便添加和更新jar包、解决jar包之间的依赖关系，以及将项目拆分成多个模块。</p><h4 id="二、Maven下载及配置（Windows）"><a href="#二、Maven下载及配置（Windows）" class="headerlink" title="二、Maven下载及配置（Windows）"></a>二、Maven下载及配置（Windows）</h4><ol><li><a href="http://maven.apache.org/download.cgi" target="_blank" rel="noopener">官网</a>下载压缩包<br><img src="https://s2.ax1x.com/2020/01/22/1kzqLn.png" alt="1kzqLn.png"></li><li>解压压缩包，自定义解压位置，路径尽可能无中文；</li><li>配置环境变量<br>a. 新建系统变量命名为MAVEN_HOME;变量值为解压包的路径。eg：            <code>F:\Java\Maven\apache-maven-3.6.3</code><br>b. 编辑系统变量Path，添加变量值： <code>;%MAVEN_HOME%\bin</code></li><li>保存退出后到终端运行：<code>mvn -v</code> 命令，显示版本信息则配置成功。</li></ol><p><img src="https://s2.ax1x.com/2020/01/22/1kxbE6.png" alt="1kxbE6.png"></p><h4 id="三、了解九个核心概念"><a href="#三、了解九个核心概念" class="headerlink" title="三、了解九个核心概念"></a>三、了解九个核心概念</h4><ol><li>POM</li><li>坐标</li><li>仓库管理</li><li>目录结构</li><li>生命周期</li><li>依赖管理</li><li>插件和目标</li><li>继承</li><li>聚合</li></ol><blockquote><p>tips：maven的各个操作都由各个插件来完成</p></blockquote><h5 id="1-POM"><a href="#1-POM" class="headerlink" title="1.POM"></a>1.POM</h5><p><strong>Project Object Model</strong>：项目对象模型。将 Java 工程的相关 <strong>信息*</strong> 封装为<strong>对象</strong>作为便于操作和管理的<strong>模型</strong>，即包含jar包或jar包的依赖关系的信息。 Maven 工程的核心配置，即在构建过程中所有的相关设置都在这里设置。可以说学习 Maven 就是学习 pom.xml 文件中的配置。</p><blockquote><p>信息是指：jar包等的名称、版本等，即上述概念中的坐标等信息，用于Maven的自动获取并使其参与项目的构建。</p></blockquote><h5 id="2-坐标"><a href="#2-坐标" class="headerlink" title="2.坐标"></a>2.坐标</h5><p>Maven中的坐标用于确定jar包或jar包的依赖关系的身份（或位置），（如同数学几何中的坐标确定点或物）</p><p>使用如下三个向量在 Maven 的仓库中唯一的确定一个jar包。<br>[1]<strong>g</strong>roupid：公司或组织的域名倒序+当前项目名称     //即项目的位置<br>[2]<strong>a</strong>rtifactId：当前项目的某一个模块的名称<br>[3]<strong>v</strong>ersion：当前模块的版本  </p><p>tips：三坐标简称 “<strong>gav</strong>”</p><p><strong>利用坐标定位jar包位置</strong></p><p>例如，我的repository仓库下的一个插件：compile编译插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure><p>组合起来是：<code>&quot;org.apache.maven.plugins&quot; + &quot;maven-compiler-plugin&quot; + &quot;3.8.1&quot;</code><br>转换为文件路径：<code>org\apache\maven\plugins\maven-compiler-plugin\3.8.1</code></p><blockquote><p>为什么我要用编译插件，因为它花了我一个下午时间，就是编译插件版本太低导致编译出错，关键下了最新版之后还是改不动它，它依旧用的是原版本，先记个仇，后面再解决。</p></blockquote><blockquote><p>tips：如果是我们自己的Maven工程，则需要执行安装操作才会进入本地仓库：mvn install.??????????</p></blockquote><h5 id="3-Maven资源-仓-库"><a href="#3-Maven资源-仓-库" class="headerlink" title="3.Maven资源(仓)库"></a>3.Maven资源(仓)库</h5><p>Maven有三个资源库（或两个：本地和远程）</p><ol><li><p><strong>Maven本地资源库</strong>：本地存储中项目的依赖库（下载下来的jar包和其他文件）的<strong>repository文件夹</strong>。默认为C盘用户文件夹下的.m2目录文件里，可自定义保存位置。文件内部如上述定位的例子。</p></li><li><p><strong>Maven中央存储库</strong>：依赖库的来源，即没有的依赖库可到中央存储库下载到本地资源库。默认的仓库是位于国外的Maven仓库，可更换为阿里云的镜像仓库，提高下载速度。中央仓库是远程仓库的特例，或者说常用、资源较多的远程仓库。</p></li></ol><blockquote><p>镜像仓库用于分担中央仓库的流量，提高用户访问和下载速度。</p></blockquote><ol start="3"><li><strong>Maven远程存储库</strong>：依赖库的来源，只要能提供所需框架或jar包，都称为远程仓库。在POM.xml文件内自定义中央仓库没有的依赖库的获取路径。</li></ol><p>仓库中的文件：</p><ol><li>Maven的插件</li><li>自己开发的项目模块</li><li>第三方框架或jar包。</li></ol><blockquote><p>所有的文件按坐标生成的目录结构，以此统一查询或依赖</p></blockquote><p><strong>三者关系</strong>：当建立一个Maven项目，Maven会检查pom.xml文件，确定需要哪些依赖库。<strong>1.</strong> Maven首先从<strong>本地资源库</strong>寻找，如果本地没有，<strong>2.</strong> Maven自动到Maven<strong>中央存储库</strong>去下载，如果中央存储库没有所需依赖，进入第三步。<strong>3.</strong> 如果pom.xml没有指定依赖库及其获取路径，Maven报错；如果在pom.xml指定了路径，Maven按照路径去到所在的<strong>远程仓库</strong>下载。</p><h5 id="4-目录结构"><a href="#4-目录结构" class="headerlink" title="4.目录结构"></a>4.目录结构</h5><p>严格的说应该是<strong>约定的目录结构</strong>，Maven工程的源文件目录，都应该按照Maven的标准设定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">项目名</span><br><span class="line">|</span><br><span class="line">|---src                    &#x2F;&#x2F;源码目录</span><br><span class="line">|---|---main               &#x2F;&#x2F;主程序目录</span><br><span class="line">|---|---|---java           &#x2F;&#x2F;主程序下的java源文件目录</span><br><span class="line">|---|---|---resources      &#x2F;&#x2F;主程序下的资源文件目录</span><br><span class="line">|---|---test               &#x2F;&#x2F;测试程序目录</span><br><span class="line">|---|---|---java           &#x2F;&#x2F;测试程序下的java源文件目录</span><br><span class="line">|---|---|---resources      &#x2F;&#x2F;测试程序下的资源文件目录</span><br><span class="line">|                   &#x2F;&#x2F;执行命令后之后会产生不同的文件*</span><br><span class="line">|---pom.xml文件            &#x2F;&#x2F;pom.xml项目配置目录文件</span><br></pre></td></tr></table></figure><blockquote><p>tips：上述的产生不同的文件将在介绍执行命令时解释。</p></blockquote><h5 id="5-Maven的生命周期"><a href="#5-Maven的生命周期" class="headerlink" title="5.Maven的生命周期"></a>5.Maven的生命周期</h5><ul><li>1》生命周期之前，先了解一个maven工程<strong>构建的几个主要环节</strong>：<br>①<strong>清理</strong>：删除以前的编译结果，为重新编译做好准备。<br>②<strong>编译</strong>：将 Java 源程序编译为字节码文件。<br>③<strong>测试</strong>：针对项目中的关键点进行测试，确保项目在迭代开发过程中关键点的正确性。<br>④<strong>报告</strong>：在每一次测试后以标准的格式记录和展示测试结果。<br>⑤<strong>打包</strong>：将一个包含诸多文件的工程封装为一个压缩文件用于安装或部署。Java 工程对应 jar 包，Web 工程对应 war 包。<br>⑥<strong>安装</strong>：在 Maven 环境下特指将打包的结果——jar 包或 war 包安装到本地仓库中。<br>⑦<strong>部署</strong>：将打包的结果部署到远程仓库或将 war 包部署到服务器上运行。<br>tips：环节步步相扣，执行完前一环节才能执行下一环节。<br></li><li>2》再了解自动化构建：即Maven能够自动化执行构建环节从开始到终点。否则是需要人为<strong>手动通过命令逐个实现</strong>。<br></li><li>3》接下来是生命周期</li></ul><p>Maven生命周期：就是定义了<strong>各个构建环节</strong>的执行顺序，有了这个顺序，Maven才可以<strong>自动化执行构建命令</strong>。</p><p>Maven有三套相互独立的生命周期，分别是:<br>①Clean Lifecycle ：在进行真正的构建之前进行一些清理工作。<br>②Default Lifecycle ：构建的核心部分，编译，测试，打包，安装，部署等等。<br>③Site Lifecycle ：生成项目报告，站点，发布站点。 </p><p>它们是相互独立的，可以仅仅调用 clean 来清理工作目录，或者仅仅调用 site 来生成站点。当然也可以直接运行 <code>mvn clean install site</code>, 运行所有这三套生命周期。 </p><p>生命周期是由一组<strong>阶段</strong>（phase）组成，我们平时在命令行输入的命令总会对应于一个特定的阶段。比 如，运行 mvn clean，这个 clean 是 Clean 生命周期的一个阶段。有 Clean 生命周期，也有 clean 阶段。 </p><ol><li><p>Clean 生命周期<br>Clean 生命周期一共包含了三个阶段：<br>①pre-clean 执行一些需要在 clean 之前完成的工作<br>②clean 移除所有上一次构建生成的文件<br>③post-clean 执行一些需要在 clean 之后立刻完成的工作  </p></li><li><p>Site 生命周期<br>①pre-site 执行一些需要在生成站点文档之前完成的工作<br>②site 生成项目的站点文档<br>③post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备<br>④site-deploy 将生成的站点文档部署到特定的服务器上 这里经常用到的是 site 阶段和 site-deploy 阶段，用以生成和发布 Maven 站点，这可是 Maven 相当强大 的功能，Manager 比较喜欢，文档及统计数据自动生成，很好看。 </p></li><li><p>Default 生命周期<br>Default 生命周期是 Maven 生命周期中最重要的一个，绝大部分工作都发生在这个生命周期中。这里， 只解释一些比较重要和常用的阶段：<br>validate<br>generate-sources<br>process-sources<br>generate-resources<br>process-resources 复制并处理资源文件，至目标目录，准备打包。<br>compile 编译项目的源代码。<br>process-classes<br>generate-test-sources<br>process-test-sources<br>generate-test-resources<br>process-test-resources 复制并处理资源文件，至目标测试目录。<br>test-compile 编译测试源代码。<br>process-test-classes<br>test 使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。 prepare-package<br>package 接受编译好的代码，打包成可发布的格式，如 JAR。 pre-integration-test<br>integration-test<br>post-integration-test<br>verify<br>install 将包安装至本地仓库，以让其它项目依赖。<br>deploy 将最终的包复制到远程的仓库，以让其它开发人员与项目共享或部署到服务器上运行。 </p></li></ol><blockquote><p>tips：学习了解即可，有maven自动化操作</p></blockquote><p>几个基本的Maven命令<br>mvn install    安装<br>mvn clean    清理<br>mvn compile    编译<br>mvn test    测试<br>mvn package    打包</p><h5 id="6-依赖"><a href="#6-依赖" class="headerlink" title="6.依赖"></a>6.依赖</h5><p>未……………………</p><h5 id="7-插件和目标"><a href="#7-插件和目标" class="headerlink" title="7.插件和目标"></a>7.插件和目标</h5><ul><li>Maven的核心仅仅定义了抽象的生命周期，具体的任务都是交由插件完成的</li><li>每个插件都能实现多个功能，每个功能就是一个插件目标</li><li>Maven的生命周期与插件目标相互绑定，以完成某个具体的构建任务。</li></ul><p>eg：compile是插件maven-compiler-plugin的一个目标。</p><p>未……………………</p><h5 id="8-继承"><a href="#8-继承" class="headerlink" title="8.继承"></a>8.继承</h5><p>未……………………</p><h5 id="9-聚合"><a href="#9-聚合" class="headerlink" title="9..聚合"></a>9..聚合</h5><p>将多个工程拆分为模块后，需要手动逐个安装到仓库后依赖才能够生效。修改源码后也需要逐个手动进 行 clean 操作。而使用了聚合之后就可以批量进行 Maven 工程的安装、清理工作。 </p><p>如何配置聚合？ 在总的聚合工程中使用 modules/module 标签组合，指定模块工程的相对路径即可 </p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">module</span>&gt;</span>../Hello<span class="tag">&lt;/<span class="name">module</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">module</span>&gt;</span>../HelloFriend<span class="tag">&lt;/<span class="name">module</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">module</span>&gt;</span>../MakeFriends<span class="tag">&lt;/<span class="name">module</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><p>未……………………</p><p>待补：基于IDEA的Maven构建。</p><h3 id="参考文档、教程"><a href="#参考文档、教程" class="headerlink" title="参考文档、教程"></a>参考文档、教程</h3><ol><li><p><a href="https://www.bilibili.com/video/av36557763?p=9" target="_blank" rel="noopener">尚硅谷–Maven教程</a></p><blockquote><p>视频也就看文档看懵的时候来找找相关的视频，本文档主要根据其讲义总结，侵删！！</p></blockquote></li><li><p><a href="https://www.yiibai.com/maven/maven-central-repository.html#article-start" target="_blank" rel="noopener">易百教程</a></p><blockquote><p>应该是来源于官方文档，但是翻译有点菜。能看，相对好。</p></blockquote></li><li><p><a href="http://maven.apache.org/guides/getting-started/index.html" target="_blank" rel="noopener">Maven官方</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaSE-4.继承</title>
      <link href="/2020/01/17/javaSE-4-%E7%BB%A7%E6%89%BF/"/>
      <url>/2020/01/17/javaSE-4-%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<p>继承 + 多态 + </p><a id="more"></a><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>子类 <code>extends</code> 父类</p><p>父类的属性和方法子类都有，子类还可增加域、增加方法、覆盖父类的方法，但是不能删除。子类调用父类的方法属性用<code>supper</code></p><blockquote><p>有些父类私有属性和方法不能够被调用。</p></blockquote><blockquote><p>有需要可以不断继承，但不可多继承。</p></blockquote><blockquote><p>不想被继承的类或方法使用final定义。</p></blockquote><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>父类变量可以引用其本身的对象或者引用其任何子类的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Employee e;<span class="comment">//Manager类继承了Employe类</span></span><br><span class="line">e= <span class="keyword">new</span> Employee();<span class="comment">//引用其自身的对象</span></span><br><span class="line">e= <span class="keyword">new</span> Manager();<span class="comment">//或者引用子类对象</span></span><br></pre></td></tr></table></figure><p>在对象数组中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span>()</span>&#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">setBonus</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">Manager boss = <span class="keyword">new</span> Manager(……);</span><br><span class="line">Employee[] staff = <span class="keyword">new</span> Employee[<span class="number">3</span>];</span><br><span class="line">staff[<span class="number">0</span>]=boss;</span><br></pre></td></tr></table></figure><p>变量staff[0]与boss引用同一个对象，但编译器将staff[0]看成Employee对象。即使用<code>boss.setBonus(num);</code>可以用，而<code>staff[0].setBonus(num)</code>不可以用。</p><h3 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h3><p>相对底层的机制，………………未完………………</p><h3 id="类的类型转换"><a href="#类的类型转换" class="headerlink" title="类的类型转换"></a>类的类型转换</h3><p>与一般的数值强制转换相似。</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><h3 id="受保护类"><a href="#受保护类" class="headerlink" title="受保护类"></a>受保护类</h3><ol><li>仅对本类可见——private。</li><li>对所有类可见——public。</li><li>对本包和所有子类可见——protected。</li><li>对本包可见——默认（很遗憾），不需要修饰符。</li></ol><hr><p>Object类</p><h3 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h3><p>equals方法用于检测一个对象是否等于另外一个对象。即判断使用具有<strong>相同的引用</strong>。</p><h3 id="相等测试与继承"><a href="#相等测试与继承" class="headerlink" title="相等测试与继承"></a>相等测试与继承</h3><h3 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h3>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> javaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaSE--3.面向对象</title>
      <link href="/2020/01/16/javaSE-3.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2020/01/16/javaSE-3.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>第三部分 对象与类</p><blockquote><p>类+构造器+源文件剖析+文档注释+类设计技巧</p></blockquote><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li>Java是完全面向对象的</li><li>面向对象的程序是由对象组成的</li><li>面向对象：只关注对象（或需求），不关注如何实现。</li><li>面向对象与面向过程的差别：</li></ul><p><img src="https://s2.ax1x.com/2020/01/16/lvRron.md.png" alt=""></p><hr><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="1-类之间的关系"><a href="#1-类之间的关系" class="headerlink" title="1.类之间的关系"></a>1.类之间的关系</h4><ul><li>依赖：一个类的方法操控另一个类的对象，称为一个类依赖于另一个类。（即一个类中的对象需要访问另一个类的对象）</li><li>聚合：包含关系。即类A的对象包含类B的对象。</li><li>继承：一个类B拥有类A方法的基础上还有额外的的功能，称为类B继承类A。</li></ul><h4 id="2-构造对象"><a href="#2-构造对象" class="headerlink" title="2.构造对象"></a>2.构造对象</h4><p>Java中使用构造器(constructor)构造新实例，构造器是一种特殊的方法，用来构造并初始化对象。</p><p>例如.构造一个Date对象:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Date()<span class="comment">// 构造器名为Date（与类名相同），要构造对象，需在构造器前加 new操作符。</span></span><br></pre></td></tr></table></figure><p>另外，可将对象存放在一个变量中，方便多次使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date vari = <span class="keyword">new</span> Date();</span><br></pre></td></tr></table></figure><blockquote><p>注： 如例，语句 “<code>Date vari;</code>“， 定义了一个可以引用 <code>Date</code> 类型的对象<strong>变量</strong>。但变量 <code>vari</code> <strong>不是一个对象</strong>，实际上也没有引用对象。即<code>vari</code>只是一个无对象的变量，所以它不能引用任何<code>Date</code>方法。只有在后面构造一个对象或引用一个构造好的Date对象变量才能正常使用。另外，一个对象变量并没有实际包含一个对象，而仅仅是<strong>引用</strong>一个对象，即对象变量存储的是对某一个对象的引用。</p></blockquote><ul><li>无参构造器: 当类不提供构造器的时候，系统会默认一个构造器。但有构造器时，就必须按照构造器的格式创建对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ClassName();<span class="comment">//类中没有构造器时，由系统默认。</span></span><br><span class="line">————————————分割线————————————</span><br><span class="line"><span class="keyword">new</span> ClassName(<span class="string">"张三"</span>,<span class="string">"20"</span>);<span class="comment">//类提供了构造器，按构造器格式创建对象。</span></span><br></pre></td></tr></table></figure><ul><li><strong>构造器 重载 调用</strong></li></ul><p>下面这个例子很好的解释了：构造器、方法的重载、构造器的调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;       <span class="comment">//-导入java.lang.System下全部的静态成员变量--减少代码书写量</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Constructor</span></span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//-定义4个实例变量</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String color;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> weight;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Constructor C=<span class="keyword">new</span> Constructor(<span class="string">"张三"</span>,<span class="string">"蓝色"</span>,<span class="number">65.5</span>,<span class="number">26</span>);</span><br><span class="line">        out.println(C.name);</span><br><span class="line">        out.println(C.color);</span><br><span class="line">        out.println(C.weight);</span><br><span class="line">        out.println(C.age);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//-创建一个空的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Constructor</span><span class="params">()</span></span>&#123;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//-创建一个包含2个参数的构造器--构造器重载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Constructor</span><span class="params">(String name,String color)</span></span>&#123;</span><br><span class="line">        <span class="comment">//-部分实例变量赋值</span></span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.color=color;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//-创建一个包含4个参数的构造器--构造器重载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Constructor</span><span class="params">(String name,String color,<span class="keyword">double</span> weight,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="comment">//-构造器里面调用其它构造器，格式方法如下：</span></span><br><span class="line">        <span class="comment">//-1、使用this调用另一个重载构造器，只能在构造器中使用；</span></span><br><span class="line">        <span class="comment">//-2、必须写在构造器执行体的第一行语句；</span></span><br><span class="line">        <span class="keyword">this</span>(name,color);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.weight=weight;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码源于<a href="https://www.cnblogs.com/baby-zhude/p/8016290.html" target="_blank" rel="noopener">这里</a></p><p>调用构造器的具体处理步骤</p><ol><li>所有数据域被初始化为<strong>默认值</strong>（0，false，null）；</li><li>按照在类声明中出现的次序，依次执行所有域初始化语句和<em>初始化块</em>（即包含在单独花括号内的初始化语句）；</li><li>如果构造器第一行调用了第二个构造器，则执行第二个构造器主体；</li><li>执行这个构造器主体。</li></ol><ul><li>基础扩展–内存分析</li></ul><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=43896218&cid=76952146&page=64" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div></br><p><a href="https://www.sxt.cn/Java_jQuery_in_action/object-oriented.html" target="_blank" rel="noopener">视频文案</a>: 内含Java中栈、堆、方法区的特点。</p><h4 id="3-源文件剖析"><a href="#3-源文件剖析" class="headerlink" title="3.源文件剖析"></a>3.源文件剖析</h4><ol><li>每<strong>一个class类</strong>都会生成<strong>一个<code>.class</code>源文件</strong>，无论在或是不在同一个<code>.java</code>文件中，都会生成，并存放在bin文件夹中。</li><li>编写出来的源代码(即<code>.java</code>文件)都保存在src文件夹中。</li></ol><blockquote><p>回顾：<br>javac 命令编译.java文件，生成.class文件。<br>java命令执行.class文件。</p></blockquote><h4 id="4-main方法"><a href="#4-main方法" class="headerlink" title="4.main方法"></a>4.main方法</h4><p>事实上，每个类都可以有一个main方法，用于对类进行单元测试。</p><h4 id="5-包"><a href="#5-包" class="headerlink" title="5.包"></a>5.包</h4><p>包：介于javac和java之间，用于方便管理源文件的一个文件夹，可以保证类名的唯一性（即即使类名相同但是包不同，类也是不相同）。常用域名的逆序来命名：原序mrgo123.com逆序为com.mrgo123，其源文件位于com/mrgo123文件下。</p><blockquote><p>包（含类、方法、静态方法、静态域）的导入用<code>import</code>。例如上述《构造器 重载 调用》的代码例子。</p></blockquote><p><strong>类路径???</strong></p><h4 id="6-文档注释"><a href="#6-文档注释" class="headerlink" title="6.文档注释"></a>6.文档注释</h4><p>JDK中javadoc实用程序，能够由源文件生成HTML文件。</p><p>注释格式：/**  …………   <em>/。<br>注释应放置在所描述特性的前面，每个文档注释在标记后紧跟着*</em>自由格式文本**，标记由@开始，如@author。javadoc实用程序自动地将这些句子抽出来形成概要页。</p><p><strong>在自由格式文本中，可以使用HTML修饰符。</strong></p><ol><li>类注释：类注释必须放在import语句之后，类定义之前。</li><li>方法注释：放在所描述的方法前。</li><li>域注释：对公有域（常指静态常量）建立文档</li><li>通用注释。</li><li>包注释</li></ol><p><span style= "color:red">……待研究……</span></p><h4 id="7-类设计技巧"><a href="#7-类设计技巧" class="headerlink" title="7.类设计技巧"></a>7.类设计技巧</h4><ol><li>一定要保证数据私有</li><li>一定要对数据初始化</li><li>不要在类中使用过多的基本类型（即用其他的类代替多个相关的基本类型的使用）</li><li>不是所有的域都需要独立的域访问器和域更改器</li><li>将职责过多的类进行分解（例如：一个复杂的类可分解成两个更为简单的类，那就要分解）</li><li>类名和方法名要能够体现它们的职责<blockquote><p>命名类名的良好习惯是采用一个<strong>名词</strong>、前面有<strong>形容词修饰的名词</strong>（RushOrder）或<strong>动名词</strong>修饰的名词（BillingAddress）。对于方法来说，习惯是访问器方法用小写<strong>get</strong>开头 （getSalary），更改器方法用小写的<strong>set</strong>开头（setSalary）。</p></blockquote></li><li>优先使用不可变的类</li></ol><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>《java核心技术 卷1》</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> javaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaSE--2.程序结构</title>
      <link href="/2020/01/14/javaSE-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"/>
      <url>/2020/01/14/javaSE-2.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>第二部分 Java的基本程序设计结构</p><blockquote><p>部分特殊字符转义+格式化输出 + 位运算 + 格式化输出 + 命令行参数 + 不规则数组</p></blockquote><a id="more"></a><hr><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><blockquote><p>回车不代表句子结束，即一个句子可以分行写；</p></blockquote><h4 id="1-特殊字符转义"><a href="#1-特殊字符转义" class="headerlink" title="1.特殊字符转义"></a>1.特殊字符转义</h4><p>特殊字符转义：\b——退格，\r——回车</p><p>小心注释中的\u，如果注释中的\u~是Unicode编码，会在解析代码前得到转义，进而产生语法错误或者改变原来要表达的意思</p><p><img src="https://s2.ax1x.com/2020/01/14/lbyTSI.md.png" alt="lbyTSI.md.png"></p><h4 id="2-位运算"><a href="#2-位运算" class="headerlink" title="2.位运算"></a>2.位运算</h4><p>运算时先转换为二进制，再按位运算。</p><p><img src="https://s2.ax1x.com/2020/01/18/19Au8g.md.png" alt="19Au8g.md.png"></p><h4 id="3-格式化输出"><a href="#3-格式化输出" class="headerlink" title="3.格式化输出"></a>3.格式化输出</h4><p>沿用C语言函数库printf(): System.out.printf();</p><ul><li>格式化输出数值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.printf(<span class="string">"%2f"</span>,<span class="number">10000.0</span>/<span class="number">3.0</span>);</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">3333.333333</span></span><br></pre></td></tr></table></figure><ul><li>格式化输出字符</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.printf(<span class="string">"%,.2f"</span>,<span class="number">10000.0</span>/<span class="number">3.0</span>);</span><br><span class="line">System.out.printf(<span class="string">"%,(.2f"</span>,<span class="number">10000.0</span>/<span class="number">3.0</span>);</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">3</span>,<span class="number">333.33</span></span><br><span class="line">(<span class="number">3</span>,<span class="number">333.33</span>)</span><br></pre></td></tr></table></figure><h4 id="4-命令行参数"><a href="#4-命令行参数" class="headerlink" title="4.命令行参数"></a>4.命令行参数</h4><p>main方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><code>String args[]</code>参数表明main方法将接收一个字符串数组，也就是命令行参数。</p><p>例如. 如果以如下形式运行这个程序</p><p><code>java Message -g cruel world</code></p><p>args数组将包含下列内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">args[<span class="number">0</span>]:<span class="string">"-g"</span></span><br><span class="line">args[<span class="number">1</span>]:<span class="string">"cruel"</span></span><br><span class="line">args[<span class="number">2</span>]:<span class="string">"world"</span></span><br></pre></td></tr></table></figure><p>结果显示：<br><code>Goodbye,cruel world!</code></p><p>tips:程序名并未储存在args[]中。</p><h4 id="5-多维数组中的不规则数组"><a href="#5-多维数组中的不规则数组" class="headerlink" title="5.多维数组中的不规则数组"></a>5.多维数组中的不规则数组</h4><ol><li>分配具有所含行数的数组</li></ol><p><code>int[][] adds =  new int [NMAX + 1][];</code></p><blockquote><p>实际分配的是包含NMAX+1个指针的数组</p></blockquote><ol start="2"><li>分配这些行</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> n = <span class="number">0</span>;n &lt;= NMAX; n++)</span><br><span class="line">    odds[n] = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br></pre></td></tr></table></figure><blockquote><p>每个指针单独的创建数组,由此可自定义每行数组的长度</p></blockquote><ol start="3"><li>得到不规则数组<blockquote><p>由此可见Java只有一维数组，二维数组是由一维数组组合而成。</p></blockquote></li></ol><h4 id="6-枚举"><a href="#6-枚举" class="headerlink" title="6.枚举"></a>6.枚举</h4><p>当需要在几个指定的变量中选择时，可以使用枚举类型。</p><p>例如，衣服的尺寸有small,medium,large,extraLarge。则可以自定义枚举类型，表示为：<code>enum Size{small,medium,large,extraLarge};</code><br>然后使用时，声明类型变量：<code>Size s = Size.medium;</code></p><blockquote><p>Size类型变量只能存储这个类型声明中给定的某个枚举值，或者<code>null</code>.</p></blockquote><h4 id="7-大数值运算"><a href="#7-大数值运算" class="headerlink" title="7.大数值运算"></a>7.大数值运算</h4><p>当基本的数据类型不能满足精度要求时，可以使用java.math包中的两个类：<br><code>BigInteger</code>:任意精度的整数。<br><code>BigDecimal</code>:任意精度的浮点数。</p><p>将普通的数值转换为大数值，使用静态的<code>valueOf</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BigInteger a = BigInteger.valueOf(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>进行加、减、乘、除时，也不能使用常规的运算符(如+、-、<em>等)，而应该使用add(+)、mutiply (\</em>)、divide(\)等</p><p>```java<br>BigInteger c = a.add(c);//c=a+b;<br>BigInteger d = c.multiply(b.add(BigInteger.valueOf(2)));//d=c*(b+2);</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>《java核心技术 卷1》</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> javaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaSE--1.环境</title>
      <link href="/2020/01/12/javaSE-1.%E7%8E%AF%E5%A2%83/"/>
      <url>/2020/01/12/javaSE-1.%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p>jdk环境介绍 + 使用jdk命令</p><a id="more"></a><h3 id="下载-安装-设置JDK"><a href="#下载-安装-设置JDK" class="headerlink" title="#下载-安装-设置JDK"></a>#下载-安装-设置JDK</h3><p>参考网上教程！！</p><hr><h3 id="使用命令行运行java文件："><a href="#使用命令行运行java文件：" class="headerlink" title="#使用命令行运行java文件："></a>#使用命令行运行java文件：</h3><p>HelloWorld.java文件源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.print(<span class="string">"HelloWorld!!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>打开终端窗口</li><li>进入文件所在目录键入：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac HelloWorld.java   &#x2F;&#x2F; javac程序是一个java编译器，将.java文件编译成.class文件，可在&#96;&#96;HelloWorld.java&#96;&#96;前写入路径(用&#x2F;)，eg：javac com&#x2F;HelloWorld.java</span><br><span class="line">java HelloWorld         &#x2F;&#x2F;java程序启动java虚拟机，虚拟机执行.class文件中的字节码,可在&#96;&#96;HelloWorld&#96;&#96;前写入路径(用.)，eg：java com.HelloWorld</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2020/01/13/l7nOl8.png" alt="l7nOl8.png"></p><p>认识一下几个概念：</p><ol><li><p>JDK：全称Java Development Kit，编写java程序的软件开发工具包，Java的核心。内含java运行环境、java工具和java基础类库，实现编译和调试功能。</p><p> JDK内部包含的基本组件（部分）：</p><ul><li>javac——编译器，将源程序转成字节码，即 .java文件 变 .class文件</li><li>java——运行编译后的java程序即运行 .class文件</li><li>javadoc——将源文件生成HTML文档</li><li>jdb——debugger，查错工具</li><li>jar——打包工具，将相关的类文件打包成一个文件</li><li>JRE——Java运行环境</li><li>…………</li><li>详情见<a href="https://zh.wikipedia.org/wiki/JDK" target="_blank" rel="noopener">【维基百科——JDK】</a></li></ul></li><li><p>JRE：全称Java Running environment，能够提供运行Java程序的环境的一个软件，内含java虚拟机（JVM）和一些标准类库</p></li><li><p>JVM：全称Java Virtual Machine，Java虚拟机，一种能够运行Java bytecode的虚拟机，能够运行以Java语言编写的软件程序。<a href="https://zh.wikipedia.org/wiki/Java虚拟机" target="_blank" rel="noopener">【维基百科——JVM】</a></p></li></ol><blockquote><p>综上 JDK（JRE（JVM））</p></blockquote><hr><h3 id="使用集成环境"><a href="#使用集成环境" class="headerlink" title="#使用集成环境"></a>#使用集成环境</h3><ul><li>eclipse</li><li>NetBeans</li><li>IntelliJ IDEA </li><li>VScode ——编辑器</li></ul><hr><p>tips：备注一下很有意思的java小应用程序applet，用于插入HTML文件中，通过支持java的浏览器浏览。<a href="https://zh.wikipedia.org/wiki/Java_applet" target="_blank" rel="noopener">【维基百科——applet】</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> javaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简述Java入坑</title>
      <link href="/2020/01/12/%E7%AE%80%E8%BF%B0Java%E5%85%A5%E5%9D%91/"/>
      <url>/2020/01/12/%E7%AE%80%E8%BF%B0Java%E5%85%A5%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>记录一下拖了很久的选择开发方向🌚🌚<br>从开始琢磨到找master，然后到最后的确定</p></blockquote><a id="more"></a><h3 id="背景"><a href="#背景" class="headerlink" title="#背景"></a>#背景</h3><p>事情应该还得从<del>废掉的</del>大一开始，大一的时光，…………啥也不说，也没得说。嗯……直接跳大一下的暑假吧！当时是开始找了master，从他那里找了一些经验，但依旧没能确定下来，因为……<del>菜</del>，仔细的说是对各个开发方向并不了解，所以也没有定下来，然后那个暑假学了点java，<del>因为这点基础，再加上学校上的java水课，我……几乎一个学期也没学多少java，导致后面原以为不错的java才七十多，真不能忍，当然其他的课是真的多。</del> 当时也是没有注意了解各个方向或者说了解得特别少，再加上<del>课多</del>。然后我又成功的忽视了方向的选择，比较庆幸的是<del>没挂</del>，学分绩也稳了一下，现在应该是八十点几吧。（呸！偏题，就是菜）</p><p>然后……成功的苟活到了这个寒假，花了十多天搞了blog+Markdown+HTML+Git+github的深入（都是基础），然后寒假十多天后的今天（其实这篇划水文是创建后的第二天写的），经过前面在某乎，还有个掘金吧……摸鱼终于对各个方向有浅薄了解，再结合自身的情况，<del>算法、front-end、……啥的搞不了或者不想搞</del>，终于选了后端。选了后端，然后选一门语言呀，然后再想java or Python，继续搜资料，好像确实java比较香，不过无所谓，然后再去咨询了下master，他直接上来就是java。😲😲那……那就搞呗！就java。然后又去滴滴我助班，毕竟他也是java方向的，估计现在算是全栈吧！华为offer，<del>上来月薪nW，各种福利，不用几年，拥百万，走上人生巅峰，迎取白富美</del>真香！！😍😍。</p><p>“学呗”，依旧是他一贯的作风。然后问他写别的自己都不知道是什么的问题！！最后总结就是javaSE（自己加的觉得不够牢固）+javaEE+Spring boot，“够你学的了”，俺继续问……，🔨🔨“你就学弄吧，找个视频教程，老是问解决不了问题”，可不是嘛，问个啥，搞就完了。🌚🌚</p><p>然后……还是某乎，<del>真香，我曾…它来着</del>，花里胡哨乱搜：java、java开发经验、java路线、java推荐书籍…………。好了，然后又到gayhub：java、……。最后《java核心技术 卷1》特地找了最新版的（十），还有个《java编程思想》据说圣经，<del>准备入手，贼贵，于我</del>。然后就开撸。</p><p>怀着<del>饱满的热情</del> 愉快的心情，开始读，跟着书，一下忘了吃饭，吃了继续搞，new了两篇博文空白页，然后……这是和master在某谷的愉快玩耍。然后it’s time to sleep！！</p><p>第二天（0202.01.13），醒来继续刷某乎+gayhub，然后……开始撸现在的blog article。还有一篇是昨天学（不是复习吗😱😱）的一点总结。</p><h3 id="计划"><a href="#计划" class="headerlink" title="#计划"></a>#计划</h3><p>然后这里做一个搜集到的花里胡哨的东西的整理吧！</p><ul><li>Step1.javaSE————《java核心技术 卷1》+《java编程思想》+<a href="https://www.bilibili.com/video/av43896218?p=376" target="_blank" rel="noopener">尚学堂_高淇_JAVA300集最新视频教程</a>+小破站+我的blog+待续…………</li></ul><blockquote><p>tips：这一阶段还有《java疯狂讲义》+《Head First Java》。额……都挺多推的，先码着，再说吧！实验楼里的挺想搞一下！</p></blockquote><p><span style="font-size:20px;color:red">未完待续……</span></p><ul><li>Step2.javaEE+Spring boot <del>暂定</del></li></ul><p>Tips: 只是做个关于java的简单记录和规划，更细致的还在脑图里。另外还有别的CS基础的，准备分专业，到时候综合看着学吧！然后立个flag：每学一个章节到blog写一次总结</p><p>路很长，也艰辛，但，还算享受。⏳⏳</p><p>这里appreciate：</p><ul><li><p><a href="https://shansan.top" target="_blank" rel="noopener">Shan San大大</a>😘😘 </p></li><li><p>助班</p></li><li><p>Others</p></li></ul><p><span style="font-size:30px;color:red">未完待续……</span></p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git基础</title>
      <link href="/2020/01/10/Git%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/01/10/Git%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<blockquote><p>简要记录Git原理及常用操作<br><a href="https://www.processon.com/mindmap/5e20338ce4b0df93533c443d" target="_blank" rel="noopener">Git思维导图</a></p></blockquote><a id="more"></a><p><span style="color:gray">Background: 经过这几天的摸鱼，以及阅读部分Git文档的相关内容后，Git学习暂时够用了，就暂时不深入<del>学习</del>，所以来做个总结记录mark一下，Let’s go！work more！BB less！</span></p><h3 id="前言"><a href="#前言" class="headerlink" title="#前言"></a>#前言</h3><p>copy了一份鹅厂某猿的Git思维导图（含命令）——<a href="https://www.processon.com/mindmap/5e20338ce4b0df93533c443d" target="_blank" rel="noopener">Git思维导图</a></p><h4 id="概念简介"><a href="#概念简介" class="headerlink" title="概念简介"></a>概念简介</h4><p>Git：是一个开源的<span style="color:red">分布式</span>版本控制系统<br>定位：项目管理工具</p><hr><h3 id="各部分内容"><a href="#各部分内容" class="headerlink" title="#各部分内容"></a>#各部分内容</h3><h4 id="一、登录"><a href="#一、登录" class="headerlink" title="一、登录"></a>一、登录</h4><p>下载配置完之后开始使用，首先登录自己的github账户，使github与本地关联。</p><blockquote><p>$ git config –global user.name “用户名”  </p><p>$ git config –global user.email 邮箱</p></blockquote><p><span style="color:gray">tips:<code>--global</code>的作用相当于在该Git下执行的账户作为默认账户，否则每次得登录。如要更换账户，把<code>--global</code>去掉重新输入要更换的账户即可。</span></p><h4 id="二、查看配置信息"><a href="#二、查看配置信息" class="headerlink" title="二、查看配置信息"></a>二、查看配置信息</h4><blockquote><p>$ git config –list</p></blockquote><p><span style="color:gray">tips:显示账户等信息</span></p><h4 id="三、创建及初始化仓库"><a href="#三、创建及初始化仓库" class="headerlink" title="三、创建及初始化仓库"></a>三、创建及初始化仓库</h4><ul><li>法一：本地建仓：</li></ul><blockquote><p>#使某一文件夹变为仓库</p><p>$ git init</p></blockquote><p>推送还需在github上创建一个新的仓库或使用已有的仓库作为远程仓库，推送时自定义远程仓库</p><blockquote><p>#先远程和本地关联<br>$ git remote add origin [目的仓库url]</p></blockquote><blockquote><p>#再推送<br>$ git push -u origin master</p></blockquote><p><span style="color:gray">tips:在本地初始化一个Git仓库。</span></p><ul><li>法二：直接从远程仓库上clone：<blockquote><p>$ git clone [目的仓库url] (filename)</p></blockquote></li></ul><p><span style="color:gray">tips:直接克隆仓库到本地，filename可以自己定义，或者不定义。</span></p><h4 id="四、Git内部工作原理"><a href="#四、Git内部工作原理" class="headerlink" title="四、Git内部工作原理"></a>四、Git内部工作原理</h4><p><img src="https://s2.ax1x.com/2020/02/07/1cf7xx.png" alt="1cf7xx.png"></p><p>待续………………</p><h4 id="五、分支管理"><a href="#五、分支管理" class="headerlink" title="五、分支管理"></a>五、分支管理</h4><ul><li>首先可以fork + clone自己的仓库 + 修改</li><li>然后选择性执行如下命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 1. 查看当前分支命令  （直接clone下来的是 master 主干）</span><br><span class="line">$ git branch </span><br><span class="line"></span><br><span class="line">#查看所有分支命令  （查看改仓库的所有分支，显示分支列表）</span><br><span class="line">$ git branch -a</span><br><span class="line"></span><br><span class="line"># 查看所有分支的详细信息</span><br><span class="line">$ git branch -avv</span><br><span class="line"></span><br><span class="line"># 2. 新建分支命令   （新建一个名为 branchName 的分支）</span><br><span class="line">$ git branch branch-name</span><br><span class="line"></span><br><span class="line">#删除分支命令   （删除名为 branchName分支）</span><br><span class="line">$ git branch -d branchName</span><br><span class="line"></span><br><span class="line"># 3. 切换分支命令  （切换名为 branchName 分支）</span><br><span class="line">$ git checkout branchNname</span><br><span class="line"></span><br><span class="line"># 4. 在某分支上推送更新    （在 branchName分支上推送）</span><br><span class="line">$ git push origin branchName</span><br></pre></td></tr></table></figure><blockquote><p>tips：若不新建分支将在master分支上操作。但是这样做merge的时候不好。</p></blockquote><ul><li>push之后到自己的仓上点 <code>New pull request</code> 。</li></ul><h4 id="六、关于fork之后跟源仓的同步"><a href="#六、关于fork之后跟源仓的同步" class="headerlink" title="六、关于fork之后跟源仓的同步"></a>六、关于fork之后跟源仓的同步</h4><p>由于fork之后是属于自己的project，所以fork到自己账户上的project并不会随着源仓更新而更新。所以当需要跟源仓同步时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#1.添加源仓为自己fork后仓库的上游</span><br><span class="line">$ git remote add upstream  源仓clone地址</span><br><span class="line"></span><br><span class="line">#2.同步fetch上游仓库代码</span><br><span class="line">$ git checkout master &amp;&amp; git fetch upstream</span><br><span class="line"></span><br><span class="line">#3.将上游代码合并至自己fork后的仓库(master分支)中，保证自己的master分支永远是最新版本</span><br><span class="line">$ git merge upstream&#x2F;master</span><br></pre></td></tr></table></figure><h4 id="七、版本控制"><a href="#七、版本控制" class="headerlink" title="七、版本控制"></a>七、版本控制</h4><p>当你想回退到以前某一个版本的时候，就需要用到Git最核心、最关键的一部分————<strong>版本控制</strong>。</p><p>比如这里初始化了一个仓库，新建一个<code>README.md</code>文件，并进行三次内容编写，每一次内容保存后提交(commit)。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 第三个版本内容</span></span><br><span class="line">ASUS@HZY MINGW64 /f/test (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat README.md</span></span><br><span class="line">The first version.</span><br><span class="line"></span><br><span class="line">The second version.</span><br><span class="line"></span><br><span class="line">The third version.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 日志展示——三个版本</span></span><br><span class="line">ASUS@HZY MINGW64 /f/test (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line">commit d5a1be6b560ac343de2271eed87c9f81e01fe8d9 (HEAD -&gt; master)</span><br><span class="line">Author: MrGo123 &lt;250……@qq.com&gt;</span><br><span class="line">Date:   Tue Mar 3 15:40:40 2020 +0800</span><br><span class="line"></span><br><span class="line">    rebuild(readme.md):third version</span><br><span class="line"></span><br><span class="line">commit 1843f71797e8ffa2f27e18a7c01a6aa8831ff032</span><br><span class="line">Author: MrGo123 &lt;250……@qq.com&gt;</span><br><span class="line">Date:   Tue Mar 3 15:38:41 2020 +0800</span><br><span class="line"></span><br><span class="line">    reBuild(readme.md):second version</span><br><span class="line"></span><br><span class="line">commit 0c3671095671c29d64d14321da9980bddff991c9</span><br><span class="line">Author: MrGo123 &lt;250……@qq.com&gt;</span><br><span class="line">Date:   Tue Mar 3 15:36:20 2020 +0800</span><br><span class="line"></span><br><span class="line">    build(readme.md):Add README.md</span><br></pre></td></tr></table></figure><p>tips:1.日志内容太多可以用 <code>$ git log --pretty=oneline</code> 来单行显示。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.<code>commit id</code>（版本号）就是commit后面的十六进制码。</p><p>可以看到HEAD指向最新版本也就是 <code>third version</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌────┐</span><br><span class="line">│HEAD│</span><br><span class="line">└────┘</span><br><span class="line">   │</span><br><span class="line">   └──&gt; ○ third version</span><br><span class="line">        │</span><br><span class="line">        ○ second version</span><br><span class="line">        │</span><br><span class="line">        ○ Add README.md</span><br></pre></td></tr></table></figure><p><strong>开始退回版本</strong>，使用到<code>git reset</code>命令。在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交d5a1be…，上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个^比较容易数不过来，所以写成<code>HEAD~100</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard HEAD^</span></span><br></pre></td></tr></table></figure><p>回退到第二个版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌────┐</span><br><span class="line">│HEAD│</span><br><span class="line">└────┘</span><br><span class="line">   │</span><br><span class="line">   │    ○ third version</span><br><span class="line">   │    │</span><br><span class="line">   └──&gt; ○ second version</span><br><span class="line">        │</span><br><span class="line">        ○ Add README.md</span><br></pre></td></tr></table></figure><p>想要回退到第三个版本，即最新的版本。可以用版本号<code>(commit id)</code>来回退。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard d5a1be <span class="comment">#id的前部分</span></span></span><br></pre></td></tr></table></figure><p>回退后结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌────┐</span><br><span class="line">│HEAD│</span><br><span class="line">└────┘</span><br><span class="line">   │</span><br><span class="line">   └──&gt; ○ third version</span><br><span class="line">        │</span><br><span class="line">        ○ second version</span><br><span class="line">        │</span><br><span class="line">        ○ Add README.md</span><br></pre></td></tr></table></figure><p>若关闭了当前的Bash窗口，<code>commit id</code>不见了怎么办，可以用 <code>git relog</code> 查看所有的版本，用显示的 <code>commit id</code>回退版本。</p><h4 id="八、添加SSH关联"><a href="#八、添加SSH关联" class="headerlink" title="八、添加SSH关联"></a>八、添加SSH关联</h4><p><strong>SSH(Secure Shell，安全外壳协议)</strong>：是一种加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境。SSH通过在网络中创建安全隧道来实现SSH客户端与服务器之间的连接。SSH最常见的用途是远程登录系统，人们通常利用SSH来传输命令行界面和远程执行命令。——<a href="https://zh.wikipedia.org/zh-cn/Secure_Shell" target="_blank" rel="noopener">维基</a></p><p>所以，在git和GitHub之间使用SSH关联，可以实现1.免登录<code>git push</code>，2.提高数据传输速度以及安全性。</p><p>实现本地Git和Github关联：</p><ol><li>终端执行 ssh-keygen 命令按几次回车生成公私钥，公私钥存放在主目录下的隐藏目录 .ssh 中的两个文件中；</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -C <span class="string">"your email@example.com"</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li>将公钥的内容复制到剪切板</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clip &lt; ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><ol start="3"><li>到github的账户信息处进入 <code>Setting</code> ➡  <code>SSH and GPG Keys</code> ➡ <code>New SSH Key</code> ➡ <code>Title随意、Key粘贴</code> ➡ <code>Add SSH Key</code>。done！</li><li>测试，<code>git bash</code>下执行如下命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure></li><li>按提示输入yes，显示successful则成功。</li></ol><h3 id="结合动态图认识一个命令"><a href="#结合动态图认识一个命令" class="headerlink" title="结合动态图认识一个命令"></a>结合动态图认识一个命令</h3><p>？？这里还没消化，先码</p><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MDA2MTI1MA==&mid=2649094728&idx=1&sn=459a3671f2afd7e832ced0c581d6f46b&chksm=be5bdde5892c54f387add99731c111e8c9bfc1b98998dfa6b2ff83b0079519a7ffbc5c4c7d6b&mpshare=1&scene=23&srcid=&sharer_sharetime=1590081929387&sharer_shareid=2cc947b5ca5c4f3edc65c12deeab5c55#rd" target="_blank" rel="noopener">用动图展示 10 个 Git 命令</a></p><h3 id="其他辅助内容"><a href="#其他辅助内容" class="headerlink" title="#其他辅助内容"></a>#其他辅助内容</h3><h4 id="一、commit规范"><a href="#一、commit规范" class="headerlink" title="一、commit规范"></a>一、commit规范</h4><p>@<a href="https://seven-innovation-base.github.io/Git-IN-ACTION-docs/2020/02/23/%E9%80%9A%E8%BF%87Git%E5%92%8CAngular%E7%90%86%E8%A7%A3%E8%AF%AD%E4%B9%89%E5%8C%96%E6%8F%90%E4%BA%A4%E4%BF%A1%E6%81%AF/" target="_blank" rel="noopener">(译)通过 Git 和 Angular 了解语义化提交信息</a></p><hr><h3 id="参考文档or推荐"><a href="#参考文档or推荐" class="headerlink" title="#参考文档or推荐"></a>#参考文档or推荐</h3><ol><li><a href="https://git-scm.com/book/en/v2" target="_blank" rel="noopener">《Pro Git》</a></li></ol><blockquote><p>Git官方Book，Chinese，详细+全面+官方，但就是太详细了，内容挺多的，留着日后再啃吧</p></blockquote><ol start="2"><li><a href="http://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="noopener">git - 简明指南</a></li></ol><blockquote><p>github上的项目，这个必须强推，常用且全面的操作都有，表层操作的话，够了,日常有需要可以翻翻</p></blockquote><ol start="3"><li><a href="https://developer.aliyun.com/lesson_489_5389?spm=5176.10731542.0.0.7f9d684eyKhz5E#_5389" target="_blank" rel="noopener">阿里云Git</a></li></ol><blockquote><p>阿里云的Git教程其实是菜鸟的，基础的方面都有，看得更舒服，读着更爽。</p></blockquote><ol start="4"><li><a href="https://guides.github.com/introduction/flow/" target="_blank" rel="noopener">github flow</a></li></ol><blockquote><p>github guide，说明指导Git及github上协作的工作流程。</p></blockquote><ol start="5"><li><a href="https://seven-innovation-base.github.io/Git-IN-ACTION-docs/2020/02/23/%E9%80%9A%E8%BF%87Git%E5%92%8CAngular%E7%90%86%E8%A7%A3%E8%AF%AD%E4%B9%89%E5%8C%96%E6%8F%90%E4%BA%A4%E4%BF%A1%E6%81%AF/" target="_blank" rel="noopener">commit规范</a></li></ol><blockquote><p>整理的commit规范写法。</p></blockquote><ol start="6"><li><a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192" target="_blank" rel="noopener">廖雪峰的Git教程</a></li></ol><blockquote><p>版本控制部分</p></blockquote><ol start="7"><li><a href="https://itrhx.blog.csdn.net/article/details/82121420" target="_blank" rel="noopener">使用 Github Pages 和 Hexo 搭建自己的独立博客【超级详细的小白教程】</a><blockquote><p>SSH关联</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> git/github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML划水</title>
      <link href="/2020/01/06/HTML%E5%88%92%E6%B0%B4_HTML/"/>
      <url>/2020/01/06/HTML%E5%88%92%E6%B0%B4_HTML/</url>
      
        <content type="html"><![CDATA[<p>整理一下HTML的知识要点</p><a id="more"></a><p style="color:LightGray">background：博客新建好了，需要的前端知识也就更多了，所以抽时间重新补一the front-end knowledge。本篇是HTML的部分内容，仅记录部分常见常用稍微重点的标签或知识。下面直接开始吧，敲就完了！！！（奥利给）</p><hr><h3 id="前言"><a href="#前言" class="headerlink" title="#前言"></a>#前言</h3><h4 id="HTML简介"><a href="#HTML简介" class="headerlink" title="HTML简介"></a>HTML简介</h4><p>HTML 指的是<strong>超文本<span style="color:red">标记<span>语言</strong> (Hyper Text Markup Language)</p><blockquote><p>简单的说就一对标签加个属性就完了</p></blockquote><hr><h3 id="正文"><a href="#正文" class="headerlink" title="#正文"></a>#正文</h3><h4 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h4><h6 id="1-HTML文档结构"><a href="#1-HTML文档结构" class="headerlink" title="1.HTML文档结构"></a>1.HTML文档结构</h6><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>第一个一级标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>第一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="2-四个基础标签"><a href="#2-四个基础标签" class="headerlink" title="2.四个基础标签"></a>2.四个基础标签</h6><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.标题（<span class="tag">&lt;<span class="name">h1</span>&gt;</span>~<span class="tag">&lt;<span class="name">h6</span>&gt;</span>）</span><br><span class="line">    eg:<span class="tag">&lt;<span class="name">h6</span>&gt;</span>六级<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br><span class="line">2.段落（<span class="tag">&lt;<span class="name">p</span>&gt;</span>）</span><br><span class="line">    eg：<span class="tag">&lt;<span class="name">p</span>&gt;</span>段落内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">3.链接（<span class="tag">&lt;<span class="name">a</span>&gt;</span>）</span><br><span class="line">    eg:<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://mrgo123.github.io"</span> <span class="attr">alt</span>=<span class="string">"我的博客地址"</span>&gt;</span>MrGo123<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">4.图像（<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"url"</span> <span class="attr">width</span>=<span class="string">"宽"</span> <span class="attr">height</span>=<span class="string">"高"</span> /&gt;</span>）</span><br><span class="line">    eg:<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"url"</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">height</span>=<span class="string">"100"</span> /&gt;</span></span><br><span class="line">    tips：<span class="tag">&lt;<span class="name">img</span> /&gt;</span>是个"自闭"标签😅😅</span><br></pre></td></tr></table></figure><h6 id="3-语法（标签-元素-属性）"><a href="#3-语法（标签-元素-属性）" class="headerlink" title="3.语法（标签+元素+属性）"></a>3.语法（标签+元素+属性）</h6><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">标签：开始标签<span class="tag">&lt;<span class="name">~</span>&gt;</span>和结束标签<span class="tag">&lt;/<span class="name">~</span>&gt;</span></span><br><span class="line">元素：处于开始和结束标签之间的内容 <span class="tag">&lt;<span class="name">~</span>&gt;</span>我是元素<span class="tag">&lt;/<span class="name">~</span>&gt;</span></span><br><span class="line">属性：可以理解为自定义标签的样式 <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span>—— href和alt就是属性</span><br><span class="line">        重点强调：class、id、style</span><br></pre></td></tr></table></figure><h4 id="二、其他重点标签介绍"><a href="#二、其他重点标签介绍" class="headerlink" title="二、其他重点标签介绍"></a>二、其他重点标签介绍</h4><h5 id="1-CSS样式—-lt-style-gt-属性"><a href="#1-CSS样式—-lt-style-gt-属性" class="headerlink" title="1.CSS样式—&lt;style&gt;属性"></a><a id="CSS"></a>1.CSS样式—&lt;style&gt;属性</h5><ul><li>外部样式（）</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"mystyle.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>HTML与CSS文档分离样式，可多个HTML文档引用</p></blockquote><ul><li>内部样式</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-tag">body</span> &#123;<span class="attribute">background-color</span>: red&#125;</span></span><br><span class="line"><span class="css"><span class="selector-tag">p</span> &#123;<span class="attribute">margin-left</span>: <span class="number">20px</span>&#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>对单个HTML文件内统一定义样式</p></blockquote><ul><li>内联样式</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"font-family:verdana;color:red"</span>&gt;</span>This is a paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="comment">&lt;!--结果是字体是verdana，字体颜色是红色--&gt;</span></span><br></pre></td></tr></table></figure><p style="font-family:verdana;color:red">This is a paragraph</p><!--结果是字体是verdana，字体颜色是红色--><blockquote><p>对单个标签定义样式</p></blockquote><h5 id="2-表格"><a href="#2-表格" class="headerlink" title="2.表格"></a>2.表格</h5><ul><li>每个表格由 table 标签开始</li><li>每个表头由 th 标签开始</li><li>每个表格行由 tr 标签开始</li><li>每个表格数据由 td 标签开始</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>一列：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>100<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>一行三列：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>100<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>200<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>300<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>两行三列：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"10"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>Heading1<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>Heading2<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>Heading3<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>100<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>200<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>300<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>400<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>500<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>600<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一列：</p><table border="0"><tr>  <td>100</td></tr></table><p>一行三列：</p><table border="1"><tr>  <td>100</td>  <td>200</td>  <td>300</td></tr></table><p>两行三列：</p><table border="10"><tr><th>Heading1</th><th>Heading2</th><th>Heading3</th></tr><tr>  <td>100</td>  <td>200</td>  <td>300</td></tr><tr>  <td>400</td>  <td>500</td>  <td>600</td></tr></table><blockquote><p>border是表格属性，用于定义边框粗细程度</p></blockquote><h5 id="3-列表"><a href="#3-列表" class="headerlink" title="3.列表"></a>3.列表</h5><p>a. 有序列表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>one<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>two<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>three<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>one</li><li>two</li><li>three</li></ol><p>b. 无序列表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>HTML<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>CSS<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Markdown<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>HTML</li><li>CSS</li><li>JavaScript</li><li>Markdown</li></ul><p>c. 定义列表</p><ul><li>自定义列表以 &lt;dl&gt; 标签开始。</li><li>每个自定义列表项以 &lt;dt&gt; 开始。</li><li>每个自定义列表项的定义以 &lt;dd&gt; 开始。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dt</span>&gt;</span>项目1<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>……项目里的内容……<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dt</span>&gt;</span>项目2<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>……项目里的内容……<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span></span></span><br></pre></td></tr></table></figure><dl><dt>项目1</dt><dd>……项目里的内容……</dd><dt>项目2</dt><dd>……项目里的内容……</dd></dl><h5 id="4-块"><a href="#4-块" class="headerlink" title="4.块"></a>4.块</h5><ul><li><p><strong>块级元素</strong> &lt;div&gt;<br>  eg: &lt;h1&gt;, &lt;p&gt;, &lt;ul&gt;, &lt;table&gt;,&lt;div&gt;,……</p><p>  &lt;div&gt; ：是可用于组合其他HTML元素的容器</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"color:#00FF00"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><div style="color:#00FF00">    <p>This is a paragraph.</p></div><ul><li><p><strong>内联元素</strong> &lt;span&gt;</p><p>  eg: &lt;b&gt;, &lt;td&gt;, &lt;a &gt;, &lt;img &gt;,……<br>  &lt;span&gt; : 可做文本容器</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is a <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"font-family:verdana;color:red"</span>&gt;</span> span <span class="tag">&lt;/<span class="name">span</span>&gt;</span> tag.</span><br></pre></td></tr></table></figure><p>This is a <span style="font-family:verdana;color:red"> span </span> tag.</p></li></ul><h5 id="5-类Class"><a href="#5-类Class" class="headerlink" title="5.类Class"></a>5.类Class</h5><p>类：可以简单理解为对HTML进行分类，使我们能够为元素的类定义不同的CSS样式。<br>直接看例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.cities</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background-color</span><span class="selector-pseudo">:lightBlue</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">color</span><span class="selector-pseudo">:white</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">margin</span><span class="selector-pseudo">:00px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">padding</span><span class="selector-pseudo">:10px</span>;</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"cities"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">London is the capital city of England. </span><br><span class="line">It is the most populous city in the United Kingdom, </span><br><span class="line">with a metropolitan area of over 13 million inhabitants.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><style>.cities {    background-color:lightBlue;    color:white;    margin:0px;    padding:10px;} </style><div class="cities"><p>London is the capital city of England. It is the most populous city in the United Kingdom, with a metropolitan area of over 13 million inhabitants.</p></div> <p>首先提取结构主要有：&lt;div&gt; 、&lt;style&gt;。再看&lt;div&gt;中的class（这就是div元素的类，其类名为 cities）,再看&lt;style&gt;内有 “<span style="color:purple">.cities{……}</span>“ ,“……”号里的就是类为cities的&lt;div&gt;的自定义属性。</p><blockquote><p>&lt;style&gt;即为上述 <a href="#CSS">CSS样式</a> ，其内部{……}属性详请学习CSS</p></blockquote><h5 id="6-布局"><a href="#6-布局" class="headerlink" title="6.布局"></a>6.布局</h5><p>HTML布局有三种形式</p><ol><li><p>使用&lt;div&gt;元素布局<br>使用&lt;div&gt;元素，通过CSS对其进行样式（含定位）调整</p></li><li><p>使用HTML5的网站布局</p></li></ol><table><thead><tr><th>语义元素</th><th>代表属性</th></tr></thead><tbody><tr><td>header</td><td>定义文档或节的页眉</td></tr><tr><td>nav</td><td>定义导航链接的容器</td></tr><tr><td>section</td><td>定义文档中的节</td></tr><tr><td>article</td><td>定义独立的自包含文章</td></tr><tr><td>aside</td><td>定义内容之外的内容（如侧栏）</td></tr><tr><td>footer</td><td>定义文档或节的页脚</td></tr><tr><td>details</td><td>定义额外的细节</td></tr><tr><td>summary</td><td>定义details元素的标题</td></tr></tbody></table><ol start="3"><li>使用表格布局<br>可以使用&lt;table&gt;表格表格化页面，用CSS样式调整表格样式</li></ol><h5 id="7-HTML响应式设计"><a href="#7-HTML响应式设计" class="headerlink" title="7.HTML响应式设计"></a>7.HTML响应式设计</h5><p>响应式设计：即能够改变网页尺寸（对不同设备有不同的网页显示效果）</p><p>创建：1.自己创建；2.使用现成的CSS框架 eg：Bootstrap</p><h5 id="8-框架"><a href="#8-框架" class="headerlink" title="8.框架"></a>8.框架</h5><p>作用：实现在同一个窗口显示多个页面</p><p>标签：</p><ul><li>框架结构标签&lt;frameset&gt;</li><li>框架标签&lt;frame&gt;</li></ul><blockquote><p>设置了一个两列的框架集。第一列被设置为占据浏览器窗口的 25%。第二列被设置为占据浏览器窗口的 75%。HTML 文档 “frame_a.htm” 被置于第一个列中，而 HTML 文档 “frame_b.htm” 被置于第二个列中：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">frameset</span> <span class="attr">cols</span>=<span class="string">"25%,75%"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"frame_a.htm"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"frame_b.htm"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br></pre></td></tr></table></figure><p>还有个内联框架&lt;iframe&gt;：在页面中自定义嵌入网页</p><h5 id="9-HTML脚本"><a href="#9-HTML脚本" class="headerlink" title="9.HTML脚本"></a>9.HTML脚本</h5><p>HTML脚本：&lt;script&gt;标签</p><blockquote><p>详学见<code>JavaScript</code></p></blockquote><h5 id="10-文件路径"><a href="#10-文件路径" class="headerlink" title="10.文件路径"></a>10.文件路径</h5><table><tr bgcolor= #DCDCDC><th>路径</th><th>描述</th></tr><tr><td>&lt;img src="picture.jpg"&gt;</td><td>picture.jpg 位于与当前网页相同的文件夹</td></tr><tr  bgcolor=GhostWhite><td>&lt;img src="images/picture.jpg"&gt;</td><td>picture.jpg 位于当前文件夹的 images 文件夹中</td></tr><tr><td>&lt;img src="/images/picture.jpg"&gt;</td><td>picture.jpg 当前站点根目录的 images 文件夹中</td></tr><tr  bgcolor=GhostWhite><td>&lt;img src="../picture.jpg"&gt;</td><td>picture.jpg 位于当前文件夹的上一级文件夹中</td></tr></table><blockquote><p>绝对路径和相对路径，优先相对路径（表上均为相对路径）</p></blockquote><h5 id="11-字符实体"><a href="#11-字符实体" class="headerlink" title="11.字符实体"></a>11.字符实体</h5><p>空格——&amp;nbsp;</p><h4 id="三、重点标签补充"><a href="#三、重点标签补充" class="headerlink" title="三、重点标签补充"></a>三、重点标签补充</h4><p><span style="color:gray">未完待续…………</span></p><p>***2</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="#参考文档"></a>#参考文档</h3><ol><li><a href="https://www.w3school.com.cn/html/index.asp" target="_blank" rel="noopener">w3school</a></li><li><a href="https://www.runoob.com/html" target="_blank" rel="noopener">菜鸟教程</a></li></ol><p><span style="color:gray">Tips:本页摘要内容基于以上两个网站的HTML教程，部分案例题材亦取于以上网站，如有侵权，还请联系我删除，thanks！！！</span></p>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown练习</title>
      <link href="/2019/12/30/markdown%E6%91%98%E8%A6%81%E7%BB%83%E4%B9%A0/"/>
      <url>/2019/12/30/markdown%E6%91%98%E8%A6%81%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>Markdown练习</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Markdown是一种轻量级标记语言</p><hr><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题  </span><br><span class="line">## 二级标题  </span><br><span class="line">### 三级标题  </span><br><span class="line">#### 四级标题  </span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题 </span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line"></span><br><span class="line"># 一级标题（有下划线） </span><br><span class="line">## 二级标题  </span><br><span class="line">### 三级标题  </span><br><span class="line">#### 四级标题  </span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题  </span><br><span class="line"></span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">### 2.块 </span><br><span class="line"></span><br><span class="line">1. 块实现</span><br></pre></td></tr></table></figure><blockquote><p>无嵌套</p><blockquote><p>一层嵌套  </p></blockquote><blockquote><blockquote><p>两层嵌套</p></blockquote></blockquote><blockquote><blockquote><blockquote><p>三层嵌套(n层……) </p></blockquote></blockquote></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 无嵌套</span><br><span class="line">&gt;&gt; 一层嵌套  </span><br><span class="line">&gt;  </span><br><span class="line">&gt;&gt;&gt; 两层嵌套</span><br><span class="line">&gt; </span><br><span class="line">&gt;&gt;&gt;&gt; 三层嵌套(n层……)  </span><br><span class="line"></span><br><span class="line">2. 块段落换行</span><br></pre></td></tr></table></figure><blockquote><p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,<br>consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.<br>Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.  </p><p>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse<br>id sem consectetuer libero luctus adipiscing.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,</span><br><span class="line">consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.</span><br><span class="line">Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.  </span><br><span class="line">&gt;</span><br><span class="line">&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse</span><br><span class="line">id sem consectetuer libero luctus adipiscing.</span><br><span class="line"></span><br><span class="line">3. 块中包含其他元素</span><br></pre></td></tr></table></figure><blockquote><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><ol><li>This <strong><em>is the first list</em></strong> item.</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; ## 二级标题</span><br><span class="line">&gt;</span><br><span class="line">&gt; 1. This ***is the first list*** item.</span><br><span class="line"></span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">### 3.表格  </span><br><span class="line">|分单元格，-分表头和行</span><br></pre></td></tr></table></figure><p>格式:<br>|  表头1  | 表头2  |<br>|  —-   | —-  |<br>| 单元格  | 单元格 |<br>| 单元格  | 单元格 |</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">|  表头1  | 表头2  |</span><br><span class="line">|  ----   | ----  |</span><br><span class="line">| 单元格  | 单元格 |</span><br><span class="line">| 单元格  | 单元格 |</span><br><span class="line"></span><br><span class="line">对齐</span><br><span class="line"></span><br><span class="line">1. -: 设置内容和标题栏居右对齐。</span><br><span class="line">2. :- 设置内容和标题栏居左对齐。</span><br><span class="line">3. :-: 设置内容和标题栏居中对齐。</span><br></pre></td></tr></table></figure><p>eg:<br>| 左对齐 | 右对齐 | 居中对齐 |<br>| :—– | —-:  | :—-: |<br>| 单元格 | 单元格 | 单元格 |<br>| 单元格 | 单元格 | 单元格 |</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :----- | ----:  | :----: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line"></span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">### 4.无序列表(*,+,-)</span><br></pre></td></tr></table></figure><p>*：</p><ul><li>一</li><li>二</li><li>三</li></ul><p>+：</p><ul><li>a</li><li>b</li><li>c </li></ul><p>-:</p><ul><li>1</li><li>2</li><li>3<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*：</span><br><span class="line">* 一</span><br><span class="line">* 二</span><br><span class="line">* 三</span><br><span class="line"></span><br><span class="line">+：</span><br><span class="line">+ a</span><br><span class="line">+ b</span><br><span class="line">+ c </span><br><span class="line"></span><br><span class="line">-:</span><br><span class="line">- 1</span><br><span class="line">- 2</span><br><span class="line">- 3</span><br><span class="line"></span><br><span class="line">段落样式</span><br></pre></td></tr></table></figure></li></ul><ul><li>Donec sit amet nisl. Aliquam semper ipsum sit amet velit.<br>Suspendisse id sem consectetuer libero luctus adipiscing.</li><li>Lorem ipsum dolor sit amet, consectetuer adipiscing elit.<br>Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,<br>viverra nec, fringilla in, laoreet vitae, risus.</li><li>Donec sit amet nisl. Aliquam semper ipsum sit amet velit.<blockquote><p>：包含块&gt;需要缩进四个空格或者一个制表符tab    </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.</span><br><span class="line">    Suspendisse id sem consectetuer libero luctus adipiscing.</span><br><span class="line">*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.</span><br><span class="line">Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,</span><br><span class="line">viverra nec, fringilla in, laoreet vitae, risus.</span><br><span class="line">*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.</span><br><span class="line">    &gt; 包含块&gt;：需要缩进四个空格或者一个制表符tab    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">### 5.有序列表（数字+.）</span><br></pre></td></tr></table></figure></li></ul><ol><li>one</li><li>two</li><li>three<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. one</span><br><span class="line">2. two</span><br><span class="line">3. three  </span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">### 6.代码块</span><br></pre></td></tr></table></figure>tab这是一块代码<br>tab通常只需每行（或首行）开头一个tab即可（看当前格式而定）<br>tab动手敲敲 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">    这是一块代码  </span><br><span class="line">    通常只需每行（或首行）开头一个tab即可（看当前格式而定） </span><br><span class="line">    动手敲敲  </span><br><span class="line"></span><br><span class="line">___</span><br><span class="line"></span><br><span class="line">### 7.转换HTML字符实体</span><br></pre></td></tr></table></figure><div class="footer">&copy; 2004 Foo Corporation</div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;div class&#x3D;&quot;footer&quot;&gt;</span><br><span class="line">    &amp;copy; 2004 Foo Corporation</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### 8.水平线（*,-,_ 三个三个以上均可）</span><br></pre></td></tr></table></figure></li></ol><hr><hr><hr><hr><hr><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">***</span><br><span class="line">* * * </span><br><span class="line">************</span><br><span class="line">- - - </span><br><span class="line">---</span><br><span class="line">_ _ _</span><br><span class="line"></span><br><span class="line">&lt;br &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">### 9.链接</span><br><span class="line"></span><br><span class="line">1. 内联的链接</span><br></pre></td></tr></table></figure><pre><code>格式：[显示的信息](链接地址 &quot;链接标题&quot;)eg：his is [an example](http://example.com/ &quot;Title&quot;) inline link.（有链接标题）[This link](http://example.net/) has no title attribute.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    This is [an example](http:&#x2F;&#x2F;example.com&#x2F; &quot;Title&quot;) inline link.  </span><br><span class="line">    [This link](http:&#x2F;&#x2F;example.net&#x2F;) has no title attribute.</span><br><span class="line"></span><br><span class="line">2. 引用的链接</span><br></pre></td></tr></table></figure>由两部分构成（两中括号，第二个）：  This is [an example] [id] reference-style link.                    （隔行）[id]: http://example.com/  &quot;Optional Title Here&quot;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    This is an example [id] reference-style link.  </span><br><span class="line"></span><br><span class="line">    [id]: http:&#x2F;&#x2F;example.com&#x2F;  &quot;Optional Title Here&quot;</span><br><span class="line">***</span><br><span class="line">### 10.强调</span><br><span class="line"></span><br><span class="line">用*或_</span><br></pre></td></tr></table></figure></code></pre><p><em>星号斜体强调</em><br><em>下划线斜体强调</em><br><strong>星号加粗强调</strong><br><strong>下划线加粗强调</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> *星号斜体强调*  </span><br><span class="line"> _下划线斜体强调_  </span><br><span class="line"> **星号加粗强调**  </span><br><span class="line"> __下划线加粗强调__</span><br><span class="line"></span><br><span class="line">***</span><br><span class="line">### 11.代码片段 </span><br><span class="line">格式：\&#96;&#96;&#96;片段 \&#96;&#96;&#96; </span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;javascript(可指定编程语言)</span><br><span class="line">    $(document).ready(function () &#123;</span><br><span class="line">       alert(&#39;RUNOOB&#39;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'RUNOOB'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h3 id="12-图片"><a href="#12-图片" class="headerlink" title="12.图片"></a>12.图片</h3><ol><li><p>链接的格式上加“!” </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">即：![图片名](链接 &quot;链接标题&quot;)</span><br><span class="line">eg：</span><br><span class="line">![Alt text](https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;MrGo123&#x2F;asset@2020-1-2-1.0&#x2F;headPortrait&#x2F;mybloghp.jpg)</span><br><span class="line">![Alt text](https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;MrGo123&#x2F;asset@2020-1-2-1.0&#x2F;headPortrait&#x2F;mybloghp.jpg &quot;我的头像&quot;)</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://cdn.jsdelivr.net/gh/MrGo123/asset@2020-1-2-1.0/headPortrait/mybloghp.jpg" alt="Alt text"><br><img src="https://cdn.jsdelivr.net/gh/MrGo123/asset@2020-1-2-1.0/headPortrait/mybloghp.jpg" alt="Alt text" title="我的头像"></p><ol start="2"><li><p>引用图片</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![Alt text][id]</span><br><span class="line">[id]: url&#x2F;to&#x2F;image  &quot;Optional title attribute&quot;</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://cdn.jsdelivr.net/gh/MrGo123/asset@2020-1-2-1.0/headPortrait/mybloghp.jpg" alt="Alt text" title="Optional title attribute"></p><hr><h3 id="13-反斜杠转义"><a href="#13-反斜杠转义" class="headerlink" title="13.反斜杠转义"></a>13.反斜杠转义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">\\  </span><br><span class="line">\&#96;  </span><br><span class="line">\*  </span><br><span class="line">\_  </span><br><span class="line">\&#123;\&#125;  </span><br><span class="line">\[\]  </span><br><span class="line">\(\)  </span><br><span class="line">\#  </span><br><span class="line">\+  </span><br><span class="line">\-  </span><br><span class="line">\.  </span><br><span class="line">\!</span><br></pre></td></tr></table></figure><p>\<br>`<br>*<br>_<br>{}<br>[]<br>()<br>#<br>+<br>-<br>.<br>!</p><h2 id="部分写作常用内容"><a href="#部分写作常用内容" class="headerlink" title="部分写作常用内容"></a>部分写作常用内容</h2><h4 id="插入B站播放外链"><a href="#插入B站播放外链" class="headerlink" title="插入B站播放外链"></a>插入B站播放外链</h4><p>简略步骤：某视频下点击分享–&gt;copy“嵌入代码”–&gt;copy下面代码并更改src–&gt;插入完成。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"position: relative; width: 100%; height: 0; padding-bottom: 75%;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"//player.bilibili.com/player.html?aid=43896218&amp;cid=76952146&amp;page=64"</span> <span class="attr">scrolling</span>=<span class="string">"no"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">frameborder</span>=<span class="string">"no"</span> <span class="attr">framespacing</span>=<span class="string">"0"</span> <span class="attr">allowfullscreen</span>=<span class="string">"true"</span> <span class="attr">style</span>=<span class="string">"position: absolute; width: 100%; height: 100%; left: 0; top: 0;"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure><hr><hr><h2 id="参考文档及推荐文档"><a href="#参考文档及推荐文档" class="headerlink" title="参考文档及推荐文档"></a>参考文档及推荐文档</h2><ol><li><a href="https://markdown-zh.readthedocs.io/en/latest/" target="_blank" rel="noopener">Mrakdown中文文档</a><blockquote><p>内容翻译于Markdown创始人 John Gruber 的博客</p></blockquote></li><li><a href="https://www.runoob.com/markdown/md-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a><blockquote><p>能够补充部分Markdown中文文档没有的部分,有编写演示</p></blockquote></li><li><a href="https://markdown.cn" target="_blank" rel="noopener">Markdown中文网</a><blockquote><p>内容跟Markdown中文文档差不多，联合起来瞅瞅，多多参考</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
